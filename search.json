[{"title":"Array常用方法","url":"/2021/06/24/Array/","content":"\n\nArrar 构造器私有方法ofArray.of()用于将参数依次转化为数组中的一项，然后返回新数组。而不管这个参数是数字还是其他\nArray.of(8.0); //[8]Array(8.0); //[empty * 8]Array.of(8.0, 5); // [8,5]Array.of(8.0,5);  // [8,5]Array.of(&#x27;8&#x27;); // [&quot;8&quot;]Array(&#x27;8&#x27;); // [&quot;8&quot;]\nfromArray.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。然后返回一个新数组，原数组不变。\n\n语法 : Array.from(arrayLike, callbackFn, thisArg)参数:\n\n\narrayLike : 必选,想要转换成数组的类数组对象或可迭代的对象\ncallbankFn : 可选,回调函数，新生成的数组会经过该函数的加工再返回\nthisArg : 可选,回调函数执行时this指向的值var arg = &#123;0:&#x27;a&#x27;,1:&#x27;b&#x27;,2:&#x27;c&#x27;, length:3&#125;;Array.from(arg, function(value)&#123;  //  value: 每项的键值  return value;  // 必须指定返回值，否则返回的新数组元素都为undefined&#125;,arg)// StringArray.from(&#x27;abc&#x27;); //[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]//SetArray.from(new Set([&#x27;abc&#x27;,&#x27;def&#x27;]));  //[&quot;abc &quot;,&quot;def&quot;]// MapArray.from(new Map([[1,&#x27;ab&#x27;],[2,&#x27;cd&#x27;]])) // [[1,&#x27;ab&#x27;],[2,&#x27;cd&#x27;]]\n不改变原数组的方法concat()concat() 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。[&#x27;hello&#x27;].concat([&#x27;world&#x27;])// [&quot;hello&quot;, &quot;world&quot;][&#x27;hello&#x27;].concat([&#x27;world&#x27;], [&#x27;!&#x27;])// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;]\njoin()join()方法将一个数组(或一个类数组对象)的所有元素连接成一个字符串，并返回这个字符串。如果数组只有一个项目，那么将直接返回该项目而不使用分隔符；如果没有传参，分隔符默认为逗号。var arr = [&#x27;Fire&#x27;,&#x27;Air&#x27;,&#x27;Water&#x27;];arr.join() // &quot;Fire,Air,Water&quot;arr.join(&#x27;&#x27;) // &quot;FireAirWater&quot;\nslice()slice()方法返回一个新数组，这一对象是一个由begin和end决定的原数组的浅拷贝(包括begin,不包括end).原数组不会被改变var arr = [1,2,3,4,5];arr.slice(2) //  [3,4,5]arr.slice(2,4) //[3,4]\ntoString()toString()返回一个字符串，表示指定的数组及元素[1,2,&#x27;a&#x27;,&#x27;b&#x27;].toString()//  &quot;1,2,a,b&quot;\nindexOf()indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。第一个参数为要查找的元素（必选）， 第二个参数是开始查询的位置（可选）var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;c&#x27;];arr.indexOf(&#x27;c&#x27;) // 2arr.indexOf(&#x27;c&#x27;,3) // 4\n\n改变原数组的方法pop()pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。\nvar arr = [1,2,3,4,5]console.log(arr.pop()) // 5console.log(arr)  // [1,2,3,4]\npop()原理Array.prototype.pop = function()&#123;  let arr = this,    len = arr.length;  if(len == 0)&#123;    return undefined;  &#125;  len--;  let value = arr[len];  delete arr[len]  arr.length = len;  return value;&#125;\npush()push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\nvar arr = [1,2,3,4,5]console.log(arr.push(1)) // 6console.log(arr)  // [1,2,3,4,5,1]\npush()原理Array.prototype._push = function(...items)&#123;  let arr = this,    len = arr.length,    argLen = items.length;  for(let i=0;i&lt;argLen;i++)&#123;    arr[len+i] = items[i]  &#125;  let newLength = len+argLen;  arr.length = newLength;  return newLength&#125;\nreverse()reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。\nvar arr = [1,2,3,4,5]console.log(arr.reverse()) // [5,4,3,2,1]console.log(arr)  // [5,4,3,2,1]\nsplice()splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。\nvar arr = [1,2,3,4,5]console.log(arr.splice(0,1)) // [1] 返回被删除的元素console.log(arr)  // [2,3,4,5]console.log(arr.splice(0,0,&#x27;add1&#x27;)) //[] 空数组console.log(arr)  // [&#x27;add1&#x27;,1，2,3,4,5]console.log(arr.splice(0,1,&#x27;add2&#x27;)) //[1] 返回被替换的元素console.log(arr)  // [&#x27;add2&#x27;，2,3,4,5]\nshift()shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\nvar arr = [1,2,3,4,5]console.log(arr.shift()) // 返回删除元素的值console.log(arr)  // [2,3,4,5]\nunshift()unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。\nvar arr = [1,2,3]console.log(arr.unshift(0,1,2)) // 6  返回该数组的新长度console.log(arr)  // [0,1,2,1,2,3]\nsort()sort() 方法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的，该方法改变原数组\n// 默认排序var arr = [8,16,50,6,100]console.log(arr.sort()) // [100, 16, 50, 6, 8]// 升序var arr = [8,16,50,6,100]console.log(arr.sort( function(a,b)&#123; return a-b &#125;)) // [5, 8, 16, 50, 100]// 降序var arr = [8,16,50,6,100]console.log(arr.sort( function(a,b)&#123; return b-a &#125;)) // [100,50,16,8,5]\n\n\n迭代方法遍历类型的方法最后返回的都是一个新数组。并不会改变原有数组的值\nforEach()forEach()方法用于调用数组的每一个元素，并将元素传递给回调函数。\n\n语法: array.forEach( callback(currentValue, index, array),thisArg)\n\n\ncallback: 为数组中每个元素执行的函数，该函数接收一至三个参数\ncurrentValue : 必填,当前元素\nindex : 可选,当前元素的索引值\narr : 可选,当前元素所属的数组对象\nthisArg : 可选,传递给函数的this值,如果参数为空,当前回调函数this指向window注意:1、forEach()对于空数组不会执行回调函数.2、for循环可以用continue跳过循环中的一个迭代，forEach()用continue会报错3、forEach()需要用return 跳过循环中的一个迭代，跳过之后会执行下一个迭代var arr = [1,2,3];for(var i=0;i&lt;arr.length;i++)&#123;  if(arr[i] == 2)&#123;    continue;  &#125;  console.log(arr[i]) // 1  3&#125;arr.forEach( function(value)&#123;  if(value == 2)&#123;    return;  &#125;  console.log(value)// 1  3&#125;)\nforEach原理Array.prototype._forEach = function(fn,thisArg)&#123;  if(!thisArg)&#123;    for(var i = 0; i&lt;this.length; i++)&#123;      fn(this[i],i,this)    &#125;  &#125;else&#123;    for(var i = 0; i&lt;thisArg.length; i++)&#123;      fn.call(thisArg,thisArg[i],i,thisArg)    &#125;  &#125;&#125;\n\n\n\nevery()every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试，返回一个布尔值。\n\n语法 : arr.every(callback(value, index, array), thisArg)\n\n[1,2,3].every( (value) =&gt; Number.isInteger(value) );  // true\n可以将every()方法看做一个等价于逻辑与的数组\nevery 实现原理为每个值执行回调，如果在任何时候返回false，则退出循环，整个方法返回false。如果循环终止都没有进入到if语句，说明每个条件都成立，则方法返回true\nArray.prototype._every = function(callback)&#123;  var arr = this,    len = arr.length;  for(var i = 0; i&lt;len;i++)&#123;    var value = arr[i];    if(!callback(value, i, arr))&#123;      return false;    &#125;  &#125;  return true;&#125;\nsome()some()方法every()刚好相反，即只要其中一个为true就会返回true。与every方法类似，可以将some方法看做一个等价的逻辑或数组\nsome 实现原理Array.prototype._some = function(callback)&#123;  var arr = this,    len = arr.length;  for(var i = 0; I&lt;len; i++)&#123;    var value = arr[i];    if(callback(value,i,arr))&#123;      return true;    &#125;  &#125;  return false&#125;\nfilter()filter() 方法创建一个新数组, filter会把传入的函数依次作用于每个元素，然后根据返回值是 true 还是false决定保留还是丢弃该元素。用于把Array的某些元素过滤掉，然后将剩下的元素放入新数组中返回。\n\n语法: var newArr = arr.filter(callback(element, index, array),thisArg)参数: \n\n\ncallback : 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留\nelement : 数组中正在处理的元素\nindex : 正在处理的元素在数组中的索引\narray : 当前调用filter的数组本身\n\n\nthisArg : 改变回调函数中this的指向filter()的原理Array.prototype._filter = function(callbackFn,thisArg)&#123;  if(Object.prototype.toString.call(callbackFn) !== &#x27;[object Function]&#x27;)&#123;    throw new TypeError(callbackFn + &#x27;is not a function&#x27;)  &#125;  var arr = this,     len = arr.length,    newArr=[];  for(var i = 0; i&lt;len; i++)&#123;    if(callbackFn(arr[i],i,arr))&#123;      newArr.push(arr[i])    &#125;  &#125;  return newArr;&#125;\n\nmap()\nmap() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\n\n\n语法: var newArr = array.map( function(currentValue, index, arr),thisArg)参数同forEach()\n\nmap()原理Array.prototype._map = function(callbackFn, thisArg)&#123;  if(this === null || this === undefined)&#123;    throw new TypeError(&quot;Cannot read property &#x27;_map&#x27; of null&quot;)  &#125;  if(Object.prototype.toString.call(callbackFn)!= &#x27;[object Function]&#x27;)&#123;    throw new TypeError(callbackFn+&#x27;is not a function&#x27;)  &#125;  let arr = this,    len = arr.length,    newArr = new Array(len);    for(let i = 0; i&lt;len; i++)&#123;      if(i in arr)&#123;        let kValue = arr[i];        let mappedValue = callbackFn.call(thisArg,kValue,i,arr)        newArr[i] = mappedValue;      &#125;    &#125;    return newArr;&#125;var a = [1, 2, 3]var b = a._map(function (item, i, arr) &#123;  return item * 2;&#125;)console.log(b);  //[2,4,6]\nreduce()reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\n语法 : var result = arr.reduce(callback(acc, cur, index, array), initValue)参数: \n\n\ncallback : 执行数组中每个值得函数,包含四个参数\nacc : 必选,initvalue提供的初始值,或者是 上一次电用的返回值(可以理解为收集箱,收集每次调用后的返回值)\ncur : 必选,数组中当前被处理的元素\nindex : 可选,当前元素的索引\narray : 可选,调用reduce()的数组\n\n\ninitValue : 可选,作为第一次调用时 callback的第一个参数\n\nreduce()原理Array.prototype._reduce = function(callbackFn, initValue)&#123;  // 异常处理，和map类似  if(this === null || this === undefined)&#123;    throw new TypeError(&quot;Cannot read property &#x27;_reduce&#x27; of null&quot;)  &#125;  // 处理回调类型异常  if(Object.prototype.toString.call(callbackFn)!= &#x27;[object Function]&#x27;)&#123;    throw new TypeError(callbackFn+&#x27;is not a function&#x27;)  &#125;  let arr = this,    // 判断是否传入初始值，如果没有，初始值为当前数组的第一位,否则以传入的值当做初始值    acc = arguments.length === 1 ? arr[0] : initValue,    // 若没有传入初始值，数组第一位为初始值，所以遍历要从第二位开始，也就是下标为1的位置    startIdx = arguments.length === 1 ? 1 : 0;   for(var i = startIdx; i&lt;arr.length; i++)&#123;    acc = callbackFn(acc,arr[i],i,arr);  &#125;  return acc&#125;\n\n","categories":["javascript","Array"],"tags":["数组常用方法"]},{"title":"LazyFunction","url":"/2021/06/03/LazyFunction/","content":"惰性函数\n普通函数\ntimeStamp 污染全局\n执行第一次之后，timeStamp 已经有值，但后续每次执行都会进入 if 语句// 例：var timeStamp = null;function getTimeStamp() &#123;  if (timeStamp) &#123;    return timeStamp  &#125;  timeStamp = new Date().getTime();  return timeStamp&#125;;\n惰性函数\n执行一遍外层函数，拿到需要的值后，在函数内部重写自身，返回需要的值\n后续调用 不需要每次都执行原函数 重读的代码段// 例：var getTimeStamp = function () &#123;  let timeStamp = new Date().getTime();  getTimeStamp = function () &#123;    return timeStamp;  &#125;  return getTimeStamp();&#125;\n实际应用\n\n普通函数添加事件\n每次执行都要对浏览器进行判断。 可以在第一次判断后就保留判断结果，再次执行时就不需要判断了。\n\nvar addEvent = (function () &#123;  if (window.addEventListener) &#123;    return function (el, type, fn, capture) &#123;      el.addEventListener(type, fn, capture);    &#125;  &#125; else if (window.attachEvent) &#123;    return function (el, type, fn) &#123;      el.attachEvent(&#x27;on&#x27; + type, function () &#123;        fn.call(el)      &#125;)    &#125;  &#125; else &#123;    return function (el, type, fn) &#123;      el[&#x27;on&#x27; + type] = fn;    &#125;  &#125;&#125;)();\n惰性函数添加事件\n第一次判断之后，在函数体内部重写自身，后续执行的是重写后的函数，不需要再进行无用的判断\n\nvar addEvent = function (el, type, fn, capture) &#123;  if (el.addEventlistener) &#123;    addEvent = function (el, type, fn, capture) &#123;      el.addEventlistener(type, fn, capture)    &#125;  &#125; else if (el.attachEvent) &#123;    addEvent = function (el, type, fn) &#123;      el.attachEvent(&#x27;on&#x27; + type, function () &#123;        fn.call(el)      &#125;)    &#125;  &#125; else &#123;    addEvent = function (el, type, fn) &#123;      el[&#x27;on&#x27; + type] = fn    &#125;  &#125;  return addEvent(el, type, fn, capture);&#125;\n\n","categories":["javascript","function"],"tags":["高阶函数"]},{"title":"Symbol.iterator & 生成器函数","url":"/2021/05/31/Symbol-iterator/","content":"生成器、迭代器\n\n给对象添加迭代器属性let obj = &#123;  a:1,  b:2,  c:3,  [Symbol.iterator]: function()&#123;    var index = 0;    let map = new Map();    // 把当前对象转换为Map对象    for(var key in this)&#123;      map.set(key, this[key])    &#125;    // map.keys()  键名    // map.values() 键值    // mao.entries() 键值对    return &#123;      next()&#123;        // 拿到每个键值对形成的数组        // console.log(map.entries())  =&gt; &#123;&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3&#125;        var mapEntries = [...map.entries()];        // mapEntries = [[&quot;a&quot;, 1],[&quot;b&quot;, 2],[&quot;c&quot;, 3]]        if(index &lt; map.size)&#123;          // 只要当前位置比对象的长度小 就返回打散后的map对象的当前下标的值和值为false                    // done 代表是否迭代完成          return &#123;            value:mapEntries[index++],            done:false          &#125;        &#125;        // 否则返回的值为 undefined  done为true        return &#123; value:undefined, done:true &#125;      &#125;    &#125;  &#125;&#125;\n\n生成器函数\n每次调用next函数时，只会执行到下一个yield，之后的代码不会执行。\n\nfunction* test()&#123;  let value1 = yield 1;  console.log(value1);  // &#x27;two&#x27;  let value2 = yield 2;    console.log(value2);  // &#x27;three&#x27;    let value3 = yield 3;    console.log(value3);  // &#x27;four&#x27;    let value4 = yield 4;    console.log(value4);  // undefined&#125;var iter = test();// 第一次调用传值不会被接收，第二次传值时会传递给第一个yield位置的变量  第三次传值 -&gt; 第二个yield  以此类推console.log(iter.next(&#x27;one&#x27;));  //  &#123;value: 1, done: false&#125;console.log(iter.next(&#x27;two&#x27;));  //  &#123;value: 2, done: false&#125;console.log(iter.next(&#x27;three&#x27;));  //  &#123;value: 3, done: false&#125;console.log(iter.next(&#x27;four&#x27;));  //  &#123;value: 4, done: false&#125;console.log(iter.next());  //  &#123;value: undefined, done: true&#125;\n\n使用生成器函数编写迭代器var obj = &#123;  a:1,  b:2,  c:3,  [Symbol.iterator]: function* () &#123;    var index = 0;    let map = new Map();    for(var key in this)&#123;      map.set(key, this[key])    &#125;    var mapEntries = [...map.entries()];    // 循环生成yield    while(index &lt; mapEntries.length)&#123;      yield mapEntries[index++];    &#125;  &#125;&#125; // for of  底层相当于调用了 obj[Symbol.iterator].next().valuefor (var i of obj) &#123;   console.log(i); // [&quot;a&quot;, 1]  [&quot;b&quot;, 2]  [&quot;c&quot;, 3]  undefined&#125;\n\n\n\n","categories":["javascript","function"],"tags":["生成器、迭代器"]},{"title":"Vue笔记","url":"/2021/08/10/Vue%E7%AC%94%E8%AE%B0/","content":"\n\n\n编码时需要注意的问题\n被Vue管理的函数最好写成普通函数，以保证this的指向是vm或组件的实例对象\n不被Vue管理的函数（定时器的回调函数、ajax的回调函数、Promise的回调函数等），最好写成箭头函数，这样this的指向才是vm或组件的实例对象\n\nVue中的MVVM模型\nM: 模型(Model): data中的数据\n\nV: 视图(View) : 模板代码\n\nVM: 视图模型(ViewModel) : Vue实例\n\n\n结果: ① data中所有的属性,最后都出现在了Vue的实例vm身上;\n   ② vm身上所有的属性及Vue原型上所有的属性,在Vue的模板中都可以直接使用\nVue中的数据代理\nVue中的数据代理是通过vm对象代理data对象中属性的操作(读/写)\n基本原理：\n\n① 通过Object.defineProperty()把data对象中所有属性添加到vm上。\n② 为每一个添加到vm上的属性，都指定一个getter/setter。\n③ 在getter/setter内部去操作(读/写) data中对应的数据\n\nVue中的事件事件的基本使用\n使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名。\n事件的回调需要配置在methods对象中，最终会在vm上。\nmethods中配置的函数，不要用箭头函数！否则this就不指向vm了。\nmethods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象。\n@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传其他参数。\n\n事件修饰符\nprevent：阻止默认事件\nstop：阻止事件冒泡\nonce：事件只触发一次\ncapture：使用事件的捕获模式\nself：只有event.target是当前操作的元素时才触发事件\npassive：事件的默认行为立即执行，无需等待事件回调执行完毕\n\n键盘事件（常用的按键别名）\n回车 =&gt; enter  删除 =&gt; delete (捕获“删除”和“退格”键)  退出 =&gt; esc  空格 =&gt; space  换行 =&gt; tab (特殊，必须配合keydown去使用)  上 =&gt; up  下 =&gt; down  左 =&gt; left  右 =&gt; right\n\n计算属性computed\n\n用途： 要使用的数据需要通过已有的属性加工后得来\n原理：底层借助了Objcet.defineproperty方法提供的getter和setter\nget函数什么时候执行？ (1).初次读取时会执行一次 (2).当依赖的数据发生改变时会被再次调用\n与methods实现相比，内部有缓存机制（复用），效率更高，调试方便\n计算属性最终会出现在vm上，直接读取使用即可\n如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\n\n\ndata()&#123;  return &#123;    firstName:&#x27;&#x27;,    lastName:&#x27;&#x27;  &#125;&#125;//完整写法fullName:&#123;  get()&#123;    console.log(&#x27;get被调用了&#x27;)    return this.firstName + &#x27;-&#x27; + this.lastName  &#125;,  set(value)&#123;    console.log(&#x27;set&#x27;,value)    const arr = value.split(&#x27;-&#x27;)    this.firstName = arr[0]    this.lastName = arr[1]  &#125;&#125;// 简写fullName()&#123;  console.log(&#x27;get被调用了&#x27;)  return this.firstName + &#x27;-&#x27; + this.lastName&#125;\n\n监视属性watch\n当被监视的属性存在变化时，回调函数自动调用，进行相关操作\nwatch默认不监测对象内部值得改变，可通过配置deep:true监测深层数据的变化data()&#123;  return &#123;    isHot:true  &#125;&#125;,watch:&#123;  // 完整写法  isHot:&#123;    immediate: true,  // 初始化时执行一次回调函数    deep: true,  // 开启深度监听    handler(newValue, oldValue)&#123;      /* 函数体逻辑 */    &#125;   &#125;  // 简写  isHot(newValue, oldValue)&#123;    /* 函数体逻辑 */  &#125;&#125;\n\ncomputed和watch之间的区别compouted能完成的功能，watch都可以完成。watch能完成的computed不一定能完成，例如：watch可以发送异步请求\n绑定样式class样式\n写法：:class=&#39;xxx&#39;xxx可以是字符串、数组、对象\n字符串写法适用于：类名不确定，要动态获取。\n对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n\n\n\n  &lt;div :class=&quot;mood +&#x27; &#x27;+ font&quot;&gt;字符串写法&lt;/div&gt;&lt;div :class=&quot;classArr&quot;&gt;数组写法&lt;/div&gt;&lt;div :class=&quot;classObj&quot;&gt;对象写法&lt;/div&gt;  data()&#123;    return &#123;      mood: &#x27;normal&#x27;,      font: &#x27;font&#x27;,      classArr: [&#x27;class1&#x27;, &#x27;class2&#x27;, &#x27;class3&#x27;],      classObj: &#123;        class1: false,        class2: false,      &#125;,    &#125;  &#125;\n\nstyle样式\n写法: :style=&quot;&#123;fontSize: xxx&#125;&quot;  或 :style=&quot;[a,b]&quot; &lt;div :style=&quot;&#123;font-size:40px&#125;&quot;&gt;对象写法&lt;/div&gt; &lt;div :style=&quot;[&#123;font-size:40px&#125;,&#123;color:#000&#125;]&quot;&gt;数组写法&lt;/div&gt;\n\n条件渲染v-if写法：\n  (1).v-if=&quot;表达式&quot; \n  (2).v-else-if=&quot;表达式&quot;\n  (3).v-else=&quot;表达式&quot;\n适用于：切换频率较低的场景。\n特点：不展示的DOM元素直接被移除。\n注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”\n\nv-show写法：v-show=&quot;表达式&quot;\n适用于：切换频率较高的场景。\n特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\n\n列表渲染v-for指令：\n\n用于展示列表数据\n语法： v-for=&quot;(item, index) in xxx&quot; :key:&quot;yyy&quot;    3. 可用于遍历 数组、对象、字符串、指定次数      \n\n双向绑定\n收集表单数据：  若：&lt;input type=&quot;text&quot;/&gt;    ，则v-model收集的是value值，用户输入的就是value值。  若：&lt;input type=&quot;radio&quot;/&gt;    ，则v-model收集的是value值，且要给标签配置value值。  若：&lt;input type=&quot;checkbox&quot;/&gt;          1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）      2.配置input的value属性:      &emsp;&emsp;(1).v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）      &emsp;&emsp;(2).v-model的初始值是数组，那么收集的的就是value组成的数组\n\n  备注：v-model的三个修饰符：\n\nlazy：失去焦点再收集数据\nnumber：输入字符串转为有效的数字\ntrim：输入首尾空格过滤\n\n过滤器定义：对要显示的数据进行特定的格式化后再显示(适用于一些简单逻辑的处理)。语法：\n\n注册过滤器：Vue.filter(name, callback) 或在组件的配置对象中直接写 &#123; ..., filters:&#123;name(value)&#123; return... &#125;&#125;&#125;\n使用过滤器： &#123;&#123; xxx| 过滤器名 &#125;&#125;  或  v-bind:属性=&quot;xxx | 过滤器名&quot;备注：\n过滤器可以接受额外参数，多个过滤器可以串联。\n不会改变原数据，产生新的对应的数据// 全局过滤器Vue.filter(&#x27;mySlice&#x27;, function(value)&#123;  return value.slice(0,4)&#125;)// 全局过滤器使用方式&#123;&#123;msg | mySlice&#125;&#125;  ||  :x=&quot;msg | mySlice&quot;/*********************************************/// 局部过滤器&#123;  data,  methods,  filters:&#123;    timeFormater(value, str=&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123;      return dayjs(valaue).format(str)    &#125;  &#125;&#125;// 多个参数 和 过滤器连用：&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;\n\n内置指令v-text\n作用：向其所在的节点中渲染文本内容。\n与插值语法的区别： v-text会替换掉节点中的内容，  则不会\n\nv-html\n作用： 向指定节点中渲染包含html结构的内容。\n与插值语法的区别：\nv-html会替换掉节点中的内容，  不会\nv-html可以识别html结构。\n\n\n需注意：v-html有安全性问题\n在网站上动态渲染HTML非常危险，容易导致XSS攻击\n一定要在可信的内容上使用v-html， 不要用在用户提交的内容上\n\n\n\nv-cloak\n特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性\n使用css配合v-cloak可以解决网速慢时页面展示出的问题\n\nv-once\nv-once所在节点在初次动态渲染后，就视为静态内容了。\n以后数据的改变不会引起v-once所在的结构更新，可以用于优化性能\n\nv-pre\n跳过其所在节点的编译过程。\n可以利用他跳过 没有使用指令语法、没有使用插值语法的节点， 会加快编译。\n\n自定义指令定义语法\n局部指令：new Vue(&#123;   directives:&#123;   //  &#x27;指令名&#x27;：&#x27;配置对象&#x27;   /**    * element : 使用当前指令的真实DOM    * binding : 自定义指令的信息对象    */   //  abc函数的的执行： 1. 指令与元素成功绑定时。 2. 指令所在的模板被重新解析时   // 简写   abc(element, binding)&#123;&#125;  ||  &#x27;a-bc&#x27;:function(element, binding)&#123;&#125;   // 完整写法     abc:&#123;       // 指令与元素成功绑定时       bind(element, binding)&#123;&#125;,       // 指令所在元素被插入页面时       inserted(element, binding)&#123;&#125;,       // 指令所在模板被重新解析时       update(element, binding)&#123;&#125;     &#125;   &#125;&#125;)\n全局指令Vue.directive(&#x27;abc&#x27;,&#123;  // 指令与元素成功绑定时  bind(element, binding)&#123;&#125;,  // 指令所在元素被插入页面时  inserted(element, binding)&#123;&#125;,  // 指令所在模板被重新解析时  update(element, binding)&#123;&#125;&#125;)\n\n生命周期钩子函数\nbeforeCreate 在实例初始化之后，在数据观测和事件配置之前被调用，这时的this还不能使用\ncreated 实例创建完成后调用，可以使用data内的数据和methods内的方法了，但dom节点还未挂载，不能对dom节点进行操作\nbeforeMount 在挂载开始之前被调用，相关的 render 函数首次被调用。\nmounted 挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行\nbeforeUpdate 数据更新前调用，发生在虚拟dom重新渲染之前，可以在这个钩子中继续更改状态，不会再次触发渲染过程\nupdated 虚拟dom渲染成真实dom之后调用，现在可以执行 依赖于本次更新数据的操作\nbeforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。\ndestroyed 实例销毁后调用。Vue 实例指示的所有东西都会解绑定，自定义事件会失效，但原生dom事件依然有效。\n\n常用的钩子\nmounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\nbeforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n\n组件Vue中使用组件的三个步骤\n定义组件(创建组件) 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样 区别如下：\n不能写el： 最终所有组件都要经过一个vm的管理，由vm中的el决定服务于哪个容器\ndata必须写成函数： 避免组件被复用时，数据存在引用关系\n组件结构的配置项为template\n\n\n注册组件 局部注册：new Vue的时候传入components选项 全局注册：Vue.component(&#39;组件名&#39;,组件)\n\n\n编写组件标签 \n\n注意点\n关于组件名: 一个单词组成： 第一种写法(首字母小写)：school\n 第二种写法(首字母大写)：School\n\n 多个单词组成： 第一种写法(kebab-case命名)：my-school\n 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)\n\n 备注： 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。\n 可以使用name配置项指定组件在开发者工具中呈现的名字。\n\n\n关于组件标签:   第一种写法：&lt;school&gt;&lt;/school&gt;   第二种写法：&lt;school/&gt;   备注：不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。\n\nVueComponent\n组件的本质是一个名为VueComponent的构造函数，这个构造函数是由Vue.extend 生成\n只需要写入 &lt;school/&gt; 或 &lt;school&gt;&lt;/school&gt;，Vue解析时会自动帮我们执行new VueComponent(options)\n每次调用Vue.extend， 返回的都是一个全新的VueComponent!\n关于this指向：\n组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。\nnew Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。— 注意 —内置关系：VueComponent.prototype.__proto__ === Vue.prototype为了让组件实例对象可以访问到Vue原型上的属性和方法\n\n\n\n","categories":["Vue"],"tags":["Vue笔记"]},{"title":"call()、apply()、bind()","url":"/2021/06/24/call/","content":"\n\ncall()call()的使用方法\n语法：function.call(thisObj, arg1, arg2, …)\n\n\n说明：call() 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果提供的thisObj参数为null或undefined时会自动替换为指向全局对象，原始值会被包装\n\nfunction Class1()&#123;  this.name = &quot;class1&quot;;  this.showName = function()&#123;    console.log(this.name);  &#125;&#125;function Class2()&#123;  this.name = &quot;class2&quot;;&#125;var c1 = new Class1();var c2 = new Class2();c1.showNam.call(c2); //class2\ncall()的意思是把c1的方法放到c2上执行，原来c2是没有showName()方法的,现在把c1的showName方法放进c2里执行，所以this.name应该是class2，执行的结果就是’class2’；call()方法实现继承\nfunction Class1()&#123;  this.showTxt = function()&#123;    console.log(txt)  &#125;&#125;function Class2()&#123;  Class1.call(this);&#125;var c2 = new Class2()c2.showTxt(&#x27;cc&#x27;)\n这样Class2就继承Class1了，Class1.call(this)的意思就是使用Class1对象代替this对象，那么Class2中就可以有了Class1的所有属性和方法了，c2对象就能够直接调用Class1的方法及属性，执行结果就是console.log(‘cc’);使用call()继承的弊端： 如果Class1后续向prototype添加了新的属性或方法，Class2拿不到新增的属性和方法\nClass1.prototype.name = &#x27;class1&#x27;console.log(c2.name) // undefined\ncall()原理js实现call\nfunction person(a, b, c, d) &#123;      return &#123;        name: this.name,        a: a, b: b, c: c, d: d      &#125;    &#125;    var yx = &#123; name: &#x27;yx&#x27; &#125;;    Function.prototype.newCall = function (obj, ...args) &#123;      var obj = obj || window;      obj.p = this;      /**       * var result = obj.p(...args);       * */       var newArgs = [];      for (var i = 0; i &lt; args.length; i++) &#123;        newArgs.push(&#x27;args[&#x27; + i + &#x27;]&#x27;)      &#125;      var result = eval(&#x27;obj.p(&#x27; + newArgs + &#x27;)&#x27;)      delete obj.p;      return result    &#125;    var bib = person.newCall(yx, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;)    console.log(bib);\napply()apply()的使用方法\n语法： function.apply(thisArg, [argArr])\n\n\n说明： apply()方法与call()方法类似。也是改变this指向(函数执行时所在的作用域)，然后在指定的作用域中，调用该函数，同时也会立即执行该函数。唯一的区别在于，apply()接受一个数组作为执行时的参数。\n\nvar obj = &#123;  name:&#x27;yx&#x27;&#125;;function test(firstName,lastName)&#123;  console.log(firstName + &#x27; &#x27; + this.name + &#x27; &#x27; + lastName);&#125;test.apply(obj,[&#x27;a&#x27;,&#x27;b&#x27;]) // a yx b\napply()原理function person(a,b,c,d)&#123;  return &#123;    name: this.name,    a:a,b:b,c:c,d:d  &#125;&#125;var yx = &#123;  name: &#x27;yx&#x27;&#125;Function.prototype.newApply = function(obj, arr)&#123;  var obj = obj || window, result;  obj.p = this;  if(!arr)&#123;    result = obj.p()  &#125;else&#123;    //  result = obj.p(...arr)    var newArgs = [];    for(var i=0; i&lt;arr.length; i++)&#123;      newArgs.push(&#x27;arr[&#x27;+ i +&#x27;]&#x27;)    &#125;    result = eval(&#x27;obj.p(&#x27;+ newArgs +&#x27;)&#x27;)  &#125;  delete obj.p  return result;&#125;var res = person.newApply(yx,[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]);\nbind()bind()使用方法\n语法: function.bind(thisArg, arg1, arg2, …)\n\n\n说明:  bind()方法主要就是将函数绑定到某个对象，bind()会创建一个函数，函数体内的this对象的值会被绑定到传入bind()中的第一个参数的值，例如：f.bind(obj)，实际上可以理解为obj.f()，这时f函数体内的this自然指向的是obj\n\nthis.num = 9;var moduleA = &#123;  num:81,  getNum ()&#123; return this.name &#125;&#125;var getNum = moduleA.getNumgetNum() //9.  因为这个这例子中this 指向全局windowvar boundGetNum = getNum.bind(moduleA)boundGetNum(); //81\nbind()原理Function.prototype.newBind = function()&#123;  const that = this;  var args = Array.prototype.slice.call(arguments);  var context = args.shift();  return function()&#123;    var arrSum = args.concat([...arguments])    return that.apply(context, arrSum)  &#125;&#125;\n\n\n\n\n\n\n","categories":["javascript","function"],"tags":["改变this指向"]},{"title":"debounce & throttle","url":"/2021/06/02/debounce/","content":"防抖、节流\n函数防抖\nn秒内只要触发事件，就重新计时，一直触发事件处理函数的程序永远不能被执行\n\n/**  *  fn  需要设置防抖的函数  *  time  执行时需要延迟的时间  *  triggleNow  是否马上触发第一次**/function test() &#123;  console.log(1);&#125;box.onmouseover = debounce(test, 1000, false);function debounce(fn, time, triggleNow) &#123;  var t = null;  var debounced = function () &#123;    var _self = this,      args = arguments;    if (t) &#123;      clearTimeout(t)    &#125;    if (triggleNow) &#123;      var exec = !t;      t = setTimeout(() =&gt; &#123;        t = null      &#125;, time)      if (exec) &#123;        fn.apply(_self, args)      &#125;    &#125; else &#123;      t = setTimeout(() =&gt; &#123;        fn.apply(_self, args)      &#125;, time)    &#125;  &#125;  debounced.remove = function () &#123;    clearTimeout(t);    t = null;  &#125;  return debounced&#125;\n\n函数节流\n事件被触发，n秒之内只执行一次事件处理函数\n\nvar input = document.getElementById(&#x27;input&#x27;);input.onkeyup = throttle(check, 1000);function check() &#123;  var val = this.value;  if (val.length &lt; 6) &#123;    console.log(&#x27;Invalid length&#x27;);  &#125; else &#123;    console.log(&#x27;success&#x27;);  &#125;&#125;function throttle(fn, delay)&#123;  var t = null,    begin = new Date().getTime();  return function()&#123;    var _self = this,      args = argumens,      cur = new Date().getTime();    clearTimeout(t);    if( cur - begin &gt;= delay )&#123;      fn.apply(_self, args);      begin = cur;    &#125;else&#123;      t = setTimeout( ()=&gt;&#123;        fn.apply(_self, args)      &#125;,delay)    &#125;  &#125;&#125;","categories":["javascript","function"],"tags":["防抖、节流"]},{"title":"js-cookie","url":"/2021/07/07/js-cookie/","content":"\n\n\n创建cookie// 创建一个cookie，在这整个站点中有效Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;);// 创建一个有效期为7天的cookie，在整个站点中有效Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;, &#123; expires: 7 &#125;);// 创建一个有效期为7天的cookie，只在当前页面生效Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;, &#123; expires: 7, path: &#x27;&#x27;  &#125;)\n\n读取cookieCookies.get(&quot;name&quot;) // =&gt; &#x27;value&#x27;Cookies.get(&quot;nothing&quot;) //=&gt; &#x27;undefined&#x27;// 读取所有可见的cookiesCookies.get() // =&gt; &#123; name: &#x27;value&#x27; &#125;\n\n删除cookieCookies.remove(&#x27;name&#x27;);// 如果设置了路径，在删除时也需指定路径// 例：Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;, &#123; path:&#x27;&#x27; &#125;)// 删除不存在的cookies不会报错也没有返回Cookies.remove(&#x27;name&#x27;)  // 删除失败Cookies.remove(&#x27;name&#x27;, &#123; path:&#x27;&#x27; &#125;) // 删除成功\n\n命名空间如果担心修改掉Cookies中的数据，可以使用noConflict方法定义一个新的空间，并保留原始cookies\n// 将 js-cookie api 分配给不同的变量。恢复原来的&#x27;window.Cookies&#x27;var Cookies2 = Cookies.noConflict()Cookies2.set(&#x27;name&#x27;,&#x27;value&#x27;)\n\njson相关js-cookies允许向cookie中存储json信息通过set方法传入Array或对象，而不是简单的string，那么js-cookies会自动调用JSON.stringify将传入的数据转为json\nCookies.set(&#x27;name&#x27;, &#123; foo: &#x27;bar&#x27; &#125;);Cookies.get(&#x27;name&#x27;); // =&gt; &#x27;&#123; &quot;foo&quot;: &quot;bar&quot; &#125;&#x27;Cookies.get(); // =&gt; &#123; name: &#x27;&#123; &quot;foo&quot;: &quot;bar&quot; &#125;&#x27; &#125;\n如果用getJSON方法获取Cookies，那么js-cookies会调用JSON.parse 解析 json 后返回。\nCookies.getJSON(&#x27;name&#x27;); // =&gt; &#123; foo:&#x27;bar&#x27; &#125;Cookies.getJSON();  // =&gt; &#123; name:&#123; foo: &#x27;bar&#x27; &#125; &#125;\n\nset方法支持的属性\nexpires定义有效期。如果传入Number,那么单位为天，也可以传入一个Date对象，表示有效期至Date指定时间。如果省略，cookie将成为会话cookie。默认 当用户关闭浏览器时Cookie被删除。\npathstring, 表示cookie对哪个地址可见，默认为 /\ndomainstring, 表示此cookie对哪个域名可见。改cookie也将对所有子域可见。 默认Cookie仅对创建该cookie的页面的域或其子域可见。\nsecuretrue | false, 表示cookie传输是否仅支持https，默认 无安全协议要求\n\n","categories":["浏览器存储"]},{"title":"sync修饰符","url":"/2021/08/27/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"\n\nVue中的.sync修饰符\n\n   在Vue中，子父组件组常用的通信方式就是通过 props 进行数据传递，props 值只能在父组件更新并传递给子组件，在子组件内部是不允许改变传递进来的 props 值，这样做是为了保证数据的单向流通。但有时候，需要在子组件内部改变 props 属性值并更新到组件中，这时就需要用到.sync修饰符\n\nsync修饰符做了两件事\n\n声明要传递的数据\n声明自定义事件:title.sync就是:title=&quot;title&quot; @update:title=&quot;title=$event&quot;的缩写\n\n父组件：\n&lt;child :title.sync=&quot;title&quot;&gt;&lt;/child&gt;等同于&lt;child :title=&quot;title&quot; @update:title=&quot;title = $event&quot;&gt;&lt;/child&gt;\n子组件：\n&lt;div class=&quot;doc&quot;&gt;  &lt;h1 class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;  &lt;button @click=&quot;changeTitle&quot;&gt;修改标题&lt;/button&gt;&lt;/div&gt;/**************************************************/props: &#123;  title: &#123;    type: String,  &#125;,&#125;,methods: &#123;  changeTitle() &#123;    this.$emit(&quot;update:title&quot;, &quot;新标题&quot;);  &#125;,&#125;,\n\n若要传递的值为一个对象下的多个值，可以通过v-bind.sync=&quot;doc&quot;将对象中每个值分别传给子组件\n父组件：\n&lt;child v-bind.sync=&quot;doc&quot;&gt;&lt;/child&gt;&lt;script&gt;\texport default &#123;  data() &#123;    return &#123;      doc: &#123;        title: &quot;初始标题&quot;,        content: &quot;初始内容&quot;,      &#125;,    &#125;;  &#125;,&lt;/script&gt;\n子组件：\n&lt;div class=&quot;doc&quot;&gt;  &lt;h1 class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;content&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;changeContent&quot;&gt;修改标题&lt;/button&gt;&lt;/div&gt;/**************************************************/props: &#123;  title: &#123;    type: String,  &#125;,  content:&#123;    type: String  &#125;&#125;,methods: &#123;  changeContent() &#123;    this.$emit(&quot;update:content&quot;, &quot;新内容&quot;);  &#125;,&#125;,","categories":["Vue"],"tags":["修饰符"]},{"title":"Vue中watch用法详解","url":"/2021/06/22/watch/","content":"基本用法  当data中变量的值变化时，watch监听到并且执行\nexport default &#123;  data()&#123;    return &#123;      value:&#x27;&#x27;    &#125;  &#125;,  watch:&#123;    value(newVal, oldVal)&#123;      /* 要执行操作 */     &#125;  &#125;&#125;\n\n\nhandler方法和immediate属性  上面的例子只有value的值变化时，watch才会执行。如果想从开始的时候就对value进行监听，就需要用到 handler 和 immediate属性\nwatch:&#123;  value:&#123;    handler(newVal, oldVla) &#123;      /* 要执行操作 */     &#125;,    // 当immediate 值为true时, 会立即执行handler方法    // 如果值为false，效果同上面例子    immediate:true  &#125;&#125;\n\ndeep属性（深度监听）\n当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变。需要添加deep属性对 对象进行深度监听\n\nexport default &#123;  data()&#123;    return &#123;      obj:&#123;        a: 1,        b: 2,        c:&#123;          d:3          f:4        &#125;      &#125;    &#125;  &#125;,  watch:&#123;    obj:&#123;      handler(newVal, oldVal)&#123;&#125;,      immediate:true,      deep:true    &#125;  &#125;&#125;\n\n\n此时会给整个对象的属性都加上监听，当对象属性较多时，每个值变化都会触发handler函数。如果只需要监听一个属性，可以使用字符串形式监听对象内的单个属性\n\nwatch:&#123;  &#x27;c.d&#x27;:&#123;    handler(newVla, oldVal)&#123;&#125;,    immediate:true,    deep:true  &#125;&#125;\n\n数组（一维、多维）的变化不需要通过深度监听，对象数组中对象的属性变化需要deep的深度监听\n\n","categories":["Vue"],"tags":["Vue"]},{"title":"webpack","url":"/2021/06/07/webpack/","content":"webpack.config.js配置项模板\nconst path = require(&#x27;path&#x27;),\tHtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123;  mode: &quot;development&quot;,  // development 开发环境    production  生产环境  // 入口文件  多页面要写成对象格式  entry:&#123;    // 名: 路径    index:path.resolve(__dirname, &#x27;./src/js/index.js&#x27;);  &#125;,  // 打包  outpyt:&#123;    // 打包到哪个文件夹下    path: path.resolve(__dirname, &#x27;/dist&#x27;),    filename: &#x27;js/[name].js&#x27;   //  name是一个变量，自动去寻找entry 下的文件名  &#125;,  // 配置规则  module:&#123;    rules:[      // 匹配相同文件后缀结尾的文件，规定这类文件要使用什么loader      &#123;        test: /\\.js$/,        loader: &#x27;babel-loader&#x27;,        exclude: path.resolve(__dirname, &#x27;node_modules&#x27;)  // 编译转换时 排除node_modules 内的js文件       &#125;,      &#123;        test: /\\.css$/,        // 需处理多个loader时，写成数组形式        // 处理 use 数组时， 案由下到上的顺序，先经过 css-loader  再处理 style-loader        use:[          &#x27;style-loader&#x27;,          &#x27;css-loader&#x27;        ]      &#125;,      &#123;        test: /\\.scss$/,        use:[          &#x27;style-loader&#x27;,          &#x27;css-loader&#x27;,          &#x27;scss-loader&#x27;        ]      &#125;,      &#123;        test: /\\.tpl$/,        loader: &#x27;ejs-loader&#x27;      &#125;    ]  &#125;,  // 放入实例化对象， 例： 需要处理html时，require(&#x27;html-webpack-plugin&#x27;) 需要引入对应插件（一个构造函数）  // 所有的loader 都不会导入到配置文件中， 以plugin结尾的一般都需要导入  plugins:[    new HtmlWebpackPlugin(&#123;      minify:&#123;        // 移除所有注释        removeComments: true,        // 清除所有的空格和换行        collapseWhitespace: true      &#125;,      // 打包后的文件名称      filename: &#x27;index.html&#x27;,      // 需要打包的文件      template: path.resolve(__dirname, &#x27;/src/index.html&#x27;),      // 入口文件 取决于 entry 里的键名，如果有多个，使用数组的形式      chunks:[&#x27;index&#x27;],      // 排除node_modules      excludeChunks: [&#x27;node_modules&#x27;]    &#125;)  ],  devServer:&#123;    // 当启动devServer时 自动打开浏览器    open: true,    // 主机    host: &#x27;localhost&#x27;,    // 端口号    port: 3300  &#125;&#125;\n配置运行 webpack 的命令\npackage.json\n\n&quot;scripts&quot;: &#123;  &quot;...&quot;: &quot;...&quot;,  &quot;dev&quot;: &quot;webpack-dev-server --config webpack.config.js --reason  --color  --progress&quot;,  // 打包时的命令  &quot;webpack&quot;: &quot;webpack --config webpack.config.js&quot;&#125;\ndev配置可选项webpack-dev-server          启动服务--content-base dist/        dev-server 运行的目录--hot                       热启动--config webpack.config.js  webpack配置项--progress                  打包的进度--display-modules           打包时的模块--colors                    打包时输出彩色文字--display-reasons           打包时的提示信息\n\n\n依赖项\n安装在开发环境下的–save-dev  /     -D安装在生产环境下    例：ejs–save     /    -S\n\nwebpack 必备工具:\nwebpackwebpack-cliwebpack-dev-server\n\n\n\n\n\n\n处理JS  -&gt;  ES6  ES7  ES8 装饰器  babel 编译\nES6：babel-loader@7babel-corebabel-preset-envES7:babel-plugin-transform-runtimeES8:babel-plugin-transform-decoratorsbabel-plugin-transform-decorators-legacy\n\n\n\n\n\n\n样式处理  sass -&gt; css -&gt; style\nsass-loadernode-sasscss-loaderstyle-loader\n\n\n\n\n\nForth Step:\n\n\n模板处理  ejs  ||  tpl\nejs-loader\n\n\n\n\n\n\n处理HTML\nhtml-webpack-plugin\n\n\n\n\n","categories":["webpack"],"tags":["webpack"]},{"title":"执行期上下文","url":"/2021/07/05/%E6%89%A7%E8%A1%8C%E6%9C%9F%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"执行期上下文详解(点击跳转)\n"},{"title":"接口的错误拦截","url":"/2021/06/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA/","content":"对axios进行基础配置//  main.jsimport axios from &#x27;axios&#x27;const instance = axios.create(&#123;  baseURL = &#x27;/api&#x27;,  // 根据前端的跨域方式做调整  timeout = 8000   // 设置超时时间&#125;)\n\nrequest拦截器（请求发送后端之前）instance.interceptors.request.use(  config =&gt; &#123;    console.log(config);  // config将发送到后端    config.headers.token = &#x27;此处可设置token的内容&#x27;;    return config;  &#125;,  error =&gt; &#123;  //当发生错误时，执行该部分代码    console.log(error);  //打印错误信息    return Promise.reject(error)  &#125;)\n\nresponse拦截器（数据返回后）instance.interceptors.response.use(  response =&gt; &#123;    let res = response.data;    if(&#x27;状态码正确&#x27;)&#123;      return res;    &#125;else&#123;      alert(&#x27;弹出此异常&#x27;)      return Promise.reject(&#x27;error&#x27;)    &#125;  &#125;,  error =&gt; &#123;    console.log(error),    return Promise.reject(error);  &#125;)\n\n\n\n\n\n\n","categories":["axios"]},{"title":"Promise","url":"/2021/06/07/Promise/","content":"Promise详解\nPromise 基本用法\n\npromise有三个状态:&nbsp;&nbsp;&nbsp;&nbsp;pending[待定] 初始状态 &nbsp;&nbsp;|&nbsp;&nbsp; fulfilled[实现] 成功 &nbsp;&nbsp;|&nbsp;&nbsp; rejected[被否决] 失败当promise状态发生改变时，就会触发then()里的响应函数处理后续步骤；promise 状态一经改变，状态固化，不会再改变Promise 有两种状态改变的方式，既可以从pending转变为fulfilled,也可以从pending转变为rejected.一旦状态改变,就固化了，会一直保持这个状态，不会再发生变化。当状态发生变化时，promoise.then绑定的函数会被立即调用。new Promise() 是同步执行,一旦新建会「立即执行」，无法取消。\n\n\n使用new构建一个Promise对象.Promise接受一个函数参数,该函数的两个参数分别是resolve和reject.这两个函数就是回调函数.resolve函数的作用: 在异步操作成功时调用,并将异步操作的结果作为参数传递出去;reject函数: 在异步操作失败时调用,并将异步操作报出的错误作为参数传递出去.\nPromise实例生成后,可以用then方法指定resolved状态和rejected状态的回调函数.\n// 构建Promisevar promsie = new Promise( function(resolve, reject)&#123;  if(/*异步任务执行成功*/)&#123;    resovle()  &#125;else&#123;    /*异步任务执行失败*/     reject()  &#125;&#125;)promise.then( function(data)&#123;  // resolve调用的 成功的回调函数&#125;, function(error)&#123;  // reject调用的 失败的回调函数&#125;)\nthen方法会返回一个Promise对象,它有两个参数,分别为Promise从pending变为fulfilled和rejected时的回调函数(第二个参数非必选). 这两个函数都接受Promise对象传出的值作为参数.then就是定义resolve和reject函数的,其resolve参数相当于:\nfunction resolveFun(data)&#123;  // data为promise传出的值&#125;\n新建Promise中的’resolve(data)’,相当于执行resolveFun函数.Promise新建后就会立即执行.then方法中指定的回电函数,将当前脚本所有同步任务执行完成后才会执行.\nvar promise = new Promise( function(resolve, reject)&#123;  console.log(1);  resolve();  console.log(2);&#125;)promise.then( function()&#123;  console.log(3);&#125;)console.log(4)// 输出: 1, 2, 4, 3\n由于resolve指定的是异步操作成功后的回调函数，他需要等所有同步代码执行完成后才会执行，因此最后打印 3。\n基本API.then()\n语法: Promise.prototype.then(onFulfilled, onRejected)对promise添加onFulfilled和onRejected回调, 并返回的是一个新的Promise实例(不是.then前的那个Promise实例),且将返回值作为参数传入这个新的Promise对象的resolver函数因此，我们可以使用链式写法。由于前一个回调函数返回的还是一个Promise对象（即有异步操作），后一个回调函数会等待该Promise对象的状态发生变化，才会被调用\n\n/* ajax异步回调 */function request(url, param, successFun, errorFun)&#123;  $.ajax(&#123;    type:&#x27;GET&#x27;,    url:url,    param:param,    async:true,    success: successFun,    error: errorFun  &#125;)&#125;/* 构建promise实例 */ function test(url, param)&#123;  return new Promise( function(resolve, reject)&#123;    request(url, param, resolve, reject)  &#125;)&#125;/* Promise的链式调用 */ test(&#x27;test1.html&#x27;, &#x27;&#x27;).then( function(data1)&#123;  console.log(&#x27;第一次请求成功&#x27;,data1);  return test(&#x27;test2.html&#x27;,data1)&#125;).then( function(data2)&#123;  console.log(&#x27;第二次请求成功&#x27;， data2)  return test(&#x27;test3.html&#x27;, data2)&#125;).then( function(data3)&#123;  console.log(&#x27;第三次请求成功&#x27;， data3)&#125;).catch( function(error)&#123;  // catch 捕捉前面的错误  console.log(&#x27;请求失败&#x27;, error)&#125;)\n.catch()\n语法: Promise.prototype.catch(onRejected)该方法是.then(null, onRejected)的另一种写法,用于指定发生错误时的回调函数.\n\npromise.then( function(data)&#123;&#125;)    .cathc( function(error)&#123;&#125;)/****** 等同于 ******/ promise.then( function(data)&#123;&#125;, function(error)&#123;&#125;)\nvar promise = new Promise( function(resolve, reject)&#123;  throw new Error(&#x27;error&#x27;);&#125;)/****** 等同于 ******/ var promise = new Promise( function(resolve, reject)&#123;  reject(new Error(&#x27;error&#x27;));&#125;)/* 用catch捕捉错误 */ promise.catch( function(error)&#123;  console.log(error)&#125;)// 输出： Uncaught (in promise) Error: error\nreject等同于抛出错误。promise对象的错误，会一直向后传递，直到被捕获。 即错误总会被下一个catch所捕获,then方法指定的回调函数若抛出错误,也会被下一个catch捕获. catch中也能抛错,则需要后面的catch捕获.\ntest(&#x27;test1.html&#x27;).then( function(data1)&#123;  // 要执行的操作&#125;).then(function(data2)&#123;  // 要执行的操作&#125;).catch( function(err)&#123;  // 处理前面三个Promise 产生的错误&#125;)\n上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦fulfilled了，再抛错，也不会变为rejected，就不会被catch了。\nvar promise = new Promise( function(resolve, reject)&#123;  resolve();  throw &#x27;error&#x27;&#125;)promise.catch( function(err)&#123;  console.log(err)&#125;)\n如果没有使用catch方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点\n.all()\n语法: Promise.all(iterable)该方法用于将多个Promise实例，包装成一个新的Promise实例。\n\nvar p = Promise.all([p1, p2, p3]);\n\nPromise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。\n\n当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数\nvar p1 = new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 3000, &quot;first&quot;);&#125;);var p2 = new Promise(function (resolve, reject) &#123;    resolve(&#x27;second&#x27;);&#125;);var p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(resolve, 1000, &quot;third&quot;);&#125;); Promise.all([p1, p2, p3]).then(function(values) &#123;   console.log(values); &#125;);//约 3s 后  [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;] \n当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数，如例3.9。\nvar p1 = new Promise((resolve, reject) =&gt; &#123;   setTimeout(resolve, 1000, &quot;one&quot;); &#125;); var p2 = new Promise((resolve, reject) =&gt; &#123;   setTimeout(reject, 2000, &quot;two&quot;); &#125;);var p3 = new Promise((resolve, reject) =&gt; &#123;  reject(&quot;three&quot;);&#125;);Promise.all([p1, p2, p3]).then(function (value) &#123;    console.log(&#x27;resolve&#x27;, value);&#125;, function (error) &#123;    console.log(&#x27;reject&#x27;, error);    // =&gt; reject three&#125;);// 输出 reject three\n这多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128\nfunction timerPromisefy(delay) &#123;    return new Promise(function (resolve) &#123;        setTimeout(function () &#123;            resolve(delay);        &#125;, delay);    &#125;);&#125;var startDate = Date.now();Promise.all([    timerPromisefy(1),    timerPromisefy(32),    timerPromisefy(64),    timerPromisefy(128)]).then(function (values) &#123;    console.log(Date.now() - startDate + &#x27;ms&#x27;);    console.log(values);&#125;);// 输出：133ms       //不一定，但大于128ms//      [1,32,64,128]\n\n.race()\n语法： Promise.race(iterable)该方法同样是将多个Promise实例，包装成一个新的Promise实例\n\np = Promise.race([p1,p2,p3])\nPromise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。\nvar p1 = new Promise(function(resolve, reject) &#123;     setTimeout(reject, 500, &quot;one&quot;); &#125;);var p2 = new Promise(function(resolve, reject) &#123;     setTimeout(resolve, 100, &quot;two&quot;); &#125;);Promise.race([p1, p2]).then(function(value) &#123;    console.log(&#x27;resolve&#x27;, value); &#125;, function(error) &#123;    // 不执行    console.log(&#x27;reject&#x27;, error); &#125;);// 输出：resolve twovar p3 = new Promise(function(resolve, reject) &#123;     setTimeout(resolve, 500, &quot;three&quot;);&#125;);var p4 = new Promise(function(resolve, reject) &#123;     setTimeout(reject, 100, &quot;four&quot;); &#125;);Promise.race([p3, p4]).then(function(value) &#123;    // 不执行    console.log(&#x27;resolve&#x27;, value);              &#125;, function(error) &#123;    console.log(&#x27;reject&#x27;, error); &#125;);// 输出：reject four\n在第一个promise对象变为resolve后，并不会取消其他promise对象的执行：\nvar fastPromise = new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#x27;fastPromise&#x27;);        resolve(&#x27;resolve fastPromise&#x27;);    &#125;, 100);&#125;);var slowPromise = new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#x27;slowPromise&#x27;);        resolve(&#x27;resolve slowPromise&#x27;);    &#125;, 1000);&#125;);// 第一个promise变为resolve后程序停止Promise.race([fastPromise, slowPromise]).then(function (value) &#123;    console.log(value);    // =&gt; resolve fastPromise&#125;);/** * fastPromise * resolve fastPromise * slowPromise     //仍会执行*/\n.resolve()\n语法：Promise.resolve(value);Promise.resolve(promise);Promise.resolve(thenable);可以看成 new Promise的快捷方式\n\nPromise.resolve(&#x27;Success&#x27;);/*******等同于*******/new Promise(function (resolve) &#123;  resolve(&#x27;Success&#x27;);&#125;);\n这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数。由于Promise.resolve()也是返回Promise对象，因此可以用.then()处理其返回值。\nPromise.resolve(&#x27;success&#x27;).then(function (value) &#123;  console.log(value);&#125;);// 输出： Success\n//Resolving an arrayPromise.resolve([1,2,3]).then(function(value) &#123;  console.log(value[0]);    // =&gt; 1&#125;);//Resolving a Promisevar p1 = Promise.resolve(&#x27;this is p1&#x27;);var p2 = Promise.resolve(p1);p2.then(function (value) &#123;  console.log(value);     // =&gt; this is p1&#125;);\nPromise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。\nvar p1 = Promise.resolve(&#123;   then: function (resolve, reject) &#123;     resolve(&quot;this is an thenable object!&quot;);  &#125;&#125;);console.log(p1 instanceof Promise);     // =&gt; truep1.then(function(value) &#123;  console.log(value);     // =&gt; this is an thenable object!  &#125;, function(e) &#123;  //not called&#125;);\n再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成resolved或rejected，状态不会再改变，这和新建promise是一样的。\nvar p1 = &#123;   then: function(resolve) &#123;    throw new Error(&quot;error&quot;);    resolve(&quot;Resolved&quot;);  &#125;&#125;;var p2 = Promise.resolve(p1);p2.then(function(value) &#123;  //not called&#125;, function(error) &#123;  console.log(error);       // =&gt; Error: error&#125;);//在回调函数后抛异常var p3 = &#123;   then: function(resolve) &#123;    resolve(&quot;Resolved&quot;);    throw new Error(&quot;error&quot;);  &#125;&#125;;var p4 = Promise.resolve(p3);p4.then(function(value) &#123;  console.log(value);     // =&gt; Resolved&#125;, function(error) &#123;  //not called&#125;);\n.reject()\n语法： Promise.reject(reason)这个方法和上述的Promise.resolve()类似，它也是new Promise()的快捷方式。\n\nPromise.reject(new Error(&#x27;error&#x27;));/*******等同于*******/new Promise(function (resolve, reject) &#123;  reject(new Error(&#x27;error&#x27;));&#125;);\n这段代码会让这个Promise对象立即进入rejected状态，并将错误对象传递给then指定的onRejected回调函数。\n常见问题reject 和 catch 的区别\n使用new Promise(fn)或者它的快捷方式Promise.resolve()、Promise.reject()，返回一个promise对象\n在fn中指定异步的处理 处理结果正常，调用resolve 处理结果错误，调用reject一般情况，还是建议使用第二种，因为能捕获之前的所有异常。第二种的.catch()也可以使用.then()表示，它们本质上是没有区别的，.catch === .then(null, onRejected)\n\n如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误function taskA() &#123;  console.log(x);  console.log(&quot;Task A&quot;);&#125;function taskB() &#123;  console.log(&quot;Task B&quot;);&#125;function onRejected(error) &#123;  console.log(&quot;Catch Error: A or B&quot;, error);&#125;function finalTask() &#123;  console.log(&quot;Final Task&quot;);&#125;var promise = Promise.resolve();promise  .then(taskA)  .then(taskB)  .catch(onRejected)  .then(finalTask);    // 输出： Catch Error: A or B,ReferenceError: x is not defined// 输出： Final Task\n上面例子的输出结果及流程图，可以看出，A抛错时，会按照 taskA → onRejected → finalTask这个流程来处理。A抛错后，若没有对它进行处理，状态就会维持rejected，taskB不会执行，直到catch了错误。\nfunction taskA() &#123;    console.log(x);    console.log(&quot;Task A&quot;);&#125;function taskB() &#123;    console.log(&quot;Task B&quot;);&#125;function onRejectedA(error) &#123;    console.log(&quot;Catch Error: A&quot;, error);&#125;function onRejectedB(error) &#123;    console.log(&quot;Catch Error: B&quot;, error);&#125;function finalTask() &#123;    console.log(&quot;Final Task&quot;);&#125;var promise = Promise.resolve();promise    .then(taskA)    .catch(onRejectedA)    .then(taskB)    .catch(onRejectedB)    .then(finalTask);    /** * 输出： * Catch Error: A ReferenceError: x is not defined * Task B * Final Task * */ \n将本例与上面的例子对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。\n每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据//方法1：对同一个promise对象同时调用 then 方法var p1 = new Promise(function (resolve) &#123;    resolve(100);&#125;);p1.then(function (value) &#123;    return value * 2;&#125;);p1.then(function (value) &#123;    return value * 2;&#125;);p1.then(function (value) &#123;    console.log(&quot;finally: &quot; + value);&#125;);// 输出： finally: 100//方法2：对 then 进行 promise chain 方式进行调用var p2 = new Promise(function (resolve) &#123;    resolve(100);&#125;);p2.then(function (value) &#123;    return value * 2;&#125;).then(function (value) &#123;    return value * 2;&#125;).then(function (value) &#123;    console.log(&quot;finally: &quot; + value);&#125;);// 输出： finally: 400\n第一种方法中，then的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。因此容易出现下面的错误写法：\nfunction badAsyncCall(data) &#123;    var promise = Promise.resolve(data);    promise.then(function(value) &#123;        //do something        return value + 1;    &#125;);    return promise;&#125;badAsyncCall(10).then(function(value) &#123;   console.log(value);          //想要得到11，实际输出10&#125;);//输出： 10\n正确的写法应该是：\nfunction goodAsyncCall(data) &#123;    var promise = Promise.resolve(data);    return promise.then(function(value) &#123;        //do something        return value + 1;    &#125;);&#125;goodAsyncCall(10).then(function(value) &#123;   console.log(value);&#125;);// 输出： 11\n在异步回调中抛错，不会被catch到// 异步函数中抛出的错误将像未捕获的错误一样var promise = new Promise(function(resolve, reject) &#123;  setTimeout(function() &#123;    throw &#x27;Uncaught Exception!&#x27;;  &#125;, 1000);&#125;);promise.catch(function(e) &#123;  console.log(e);       //不会调用&#125;);\npromise状态变为resove或reject，就凝固了，不会再改变console.log(1);new Promise(function (resolve, reject)&#123;    reject();    setTimeout(function ()&#123;        resolve();            //not called    &#125;, 0);&#125;).then(function()&#123;    console.log(2);&#125;, function()&#123;    console.log(3);&#125;);console.log(4);/** * 输出： * 1 * 4 * 3 * */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["javascript","Promise"],"tags":["promise"]},{"title":"Vue-cli笔记","url":"/2021/08/16/Vue-cli%E7%AC%94%E8%AE%B0/","content":"\n\n脚手架文件结构├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n\n关于不同版本的Vue\nvue.js与vue.runtime.xxx.js的区别：\nvue.js是完整版的Vue，包含：核心功能+模板编译器\nvue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。\n\n\n因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。\n\nvue.config.js 配置文件\n使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。\n使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh/config/\n\nref属性\n被用来给元素或子组件注册引用信息(id的替代者)\n应用在html标签上获取的是真实dom元素， 应用在组件标签上是组件实例对象\n使用方式\n打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt; 或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;\n获取：this.$refs.xxx\n\n\n\nprops配置项\n功能：让组件接收外部传过来的数据\n传递数据： &lt;demo :name=&quot;xxx&quot;&gt;\n接收数据：\n第一种方式（只接收）：props:[&#39;name&#39;]\n第二种方式（限制类型）： props:&#123;name:&#39;String&#39;&#125;\n第三种方式（限制类型、限制必要性、指定默认值）： props:&#123;  name:&#123;    type:String, //类型    required:true,\t// 必要性    default:&#x27;老王&#x27;\t// 默认值  &#125;&#125;\n\n\n可接受的类型- String- Number- Boolean- Array- Object- Date- Function- Symbol\n\n备注： props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若确实需要修改，可复制一份props的内容到data中，然后修改data中的数据\n\n\n\nmixin(混入)\n功能：可以把多个组件共用的配置提取成一个混入对象\n使用方式： 第一步定义混合： &#123;   data()&#123;&#125;,   methods:&#123;&#125;,   ... ... &#125;\n第二部使用混入：全局混入：Vue.mixin(xxx)局部混入：mixins:[&#39;xxx&#39;]\n\n插件\n功能：用于增强Vue\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n定义插件：export default &#123;  install(Vue, options)&#123;    // 1. 添加全局过滤器    Vue.filter(....)    // 2. 添加全局指令    Vue.directive(....)    // 3. 配置全局混入(合)    Vue.mixin(....)    // 4. 添加实例方法    Vue.prototype.$myMethod = function () &#123;...&#125;    Vue.prototype.$myProperty = xxxx  &#125;&#125;\n使用插件：Vue.use(xxx)\n\nscoped样式\n作用：让样式在局部生效，防止冲突\n写法：&lt;style scoped&gt;\n\n组件拆分案例\n组件化编码流程 (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突 (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用： 1). 一个组件在用，放在自身即可。\n 2). 多个组件在用：放在他们共同的父组件上（&lt;span style=&quot;color:red&quot;&gt;状态提升&lt;/span&gt;）\n\n (3).实现交互： 从绑定开始\nprops适用于： (1). 父组件 ==&gt; 子组件 通信 (2). 子组件 =&gt;&gt; 父组件 通信（需要父组件先给子组件一个函数，子组件调用时传参）\n使用v-model时要切记： v-model绑定的值不能是props传过来的值，因为props不可修改\nprops传过来的若是对象的值，修改对象中的属性是Vue不会报错，但不推荐这样做\n\nwebStorage\n存储内容大小一般支持5MB左右（不同浏览器之间可能会有区别）\n\n浏览器端通过 window.sessionStorage 和 window.localStorage属性实现本地存储机制\n\n相关API：\n\nxxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\nxxxxxStorage.getItem(&#39;person&#39;); ​该方法接受一个键名作为参数，返回键名对应的值。\n\nxxxxxStorage.removeItem(&#39;key&#39;); ​该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n xxxxxStorage.clear() ​该方法会清空存储中的所有数据。\n\n\n\n备注：\n\nSessionStorage存储的内容会随着浏览器的窗口关闭而消失\nLocalStorage存储的内容，需要手动清除才会消失\nxxxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null\nJSON.parse(null) 的结果依然是null\n\n\n\n组件的自定义事件\n一种组件间通信的方法，适用于：子组件 ===&gt; 父组件\n\n使用场景： A是父组件，B是子组件，B想给A传递数据，就要在A中给B绑定自定义事件（事件的回调在A中）。\n\n绑定自定义事件：\n\n第一种方法，在父组件中：&lt;Demo @children=&quot;parent&quot; /&gt;\n第二种方法，在父组件中：  &lt;Demo ref=&quot;demo&quot; /&gt;...mounted()&#123;  this.$refs.xxx.$on(&#x27;子组件事件名&#x27;,this.getData/*父组件自己的方法*/)&#125;\n若只想让自定义事件触发一次，可以使用once修饰符，或$once方法\n\n\n触发自定义事件：this.$emit(&#39;事件名&#39;,要传递的数据)\n\n解绑自定义事件：this.$off(&#39;事件名&#39;)\n\n组件上也可以绑定原生的dom事件，需要用native修饰符。\n\n注意：通过this.$refs.xxx.$on(&#39;子组件事件名&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！\n\n\n全局事件总线(GlobalEventBus)\n一种组件间通信的方式，适用于任意组件间通信\n\n安装全局事件总线：\n new Vue(&#123;  ....,  beforeCreate()&#123;    Vue.prototype.$bus = this //安装全局事件总线, $bus就是当前应用的vm  &#125;,  ....&#125;)\n使用事件总线：\n\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身\n提供数据： this.$bus.$emit(&#39;tt&#39;,数据)\n\n\n最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。\n   // A组件methods:&#123;  demo(data)&#123; ... &#125;&#125;... ...mounted()&#123;  this.$bus.$on(&#x27;tt&#x27;,this.demo)&#125;,beforeDestroy() &#123;  this.$bus.$off(&quot;tt&quot;);&#125;// B组件methods:&#123;  test()&#123;    this.$bus.$emit(&#x27;tt&#x27;,params)  &#125;&#125;\n\n消息订阅与发布（pubsub）\n一种组件间通信的方式，适用于任意组件间通信\n\n使用步骤:\n\n安装pubsub：npm i  pubsub-js\n引入：import pubsub from &#39;pubsub-js&#39;\n接收数据：A组件想接受的数据，则在A组件中订阅消息，订阅的回调留在A组件自身。\n提供数据： pubsub.publish(&#39;xxx&#39;, 数据)\n最好在beforeDestroy钩子中,用pubsub.unsubscribe(this.pid)去取消订阅。// A组件methods:&#123;  // 第一个参数是订阅事件的名字  demo(&#x27;aaa&#x27;,data)&#123; ... &#125;&#125;,... ...mounted()&#123;  this.pid = pubsub.subscribe(&#x27;aaa&#x27;,this.demo) //订阅消息&#125;,beforeDestroy()&#123;  pubsub.unsubscribe(this.pid)&#125;// B组件methods:&#123;  test()&#123;    pubsub.publish(&#x27;aaa&#x27;,params)  &#125;&#125;\n\n\n\nnextTick\n语法： this.$nextTick(callback)\n作用： 在下一次 dom 更新结束后执行其指定的回调函数\n什么时候用： 当改变数据后，要给予更新后的 dom 进行某些操作时，要在nextTick所指定的回调函数中执行\n\nVue封装的过渡与动画transition\n原理\n自动查看目标元素是否应用了CSS过渡或动画，如果有，那么在恰当的时机添加/删除CSS类名\n如果trnasition组件提供了JavaScript钩子函数，这些钩子函数将在恰当的时机被调用\n如果没有找到JavaScript钩子并且也没有检测到CSS过渡/动画，DOM插入、删除操作会立即执行\n\n\n\n\nv-enter-from: 定义过度开始的状态，在元素被插入之前生效，在元素被插入之后的下一帧移除\nv-enter-active: 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数\nv-enter-to: 定义进入过渡的结束状态。在元素被插入之后下一帧生效(此时v-enter-from)被移除，在过渡/动画完成之后移除\nv-leave-from: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧移除\nv-leave-active: 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过度被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数\nv-leave-to: 离开过渡的结束状态。在离开过渡被触发之后下一帧生效(此时v-leave-from被删除)，在过渡/动画完成之后移除\n\n  &lt;transition name=&quot;tt&quot;&gt;    &lt;h2 v-if=&quot;isShow&quot;&gt;Hello World!&lt;/h2&gt;&lt;/transition&gt;&lt;style&gt;  .tt-enter-from,    .tt-leave-to&#123;        // 变化效果        opacity: 0    &#125;        .tt-enter-to,    .tt-leave-from&#123;        // 变化效果        opacity: 1    &#125;        .tt-enter-active,    .tt-leave-active&#123;        transition: opacity 1s;    &#125;&lt;/style&gt;\n\n\nclass的name命名规则\n如果使用的是一个没有name的transition。那么所有class都是以v-作为默认前缀\n如果我们添加了一个name属性，比如&lt;transition name=&quot;tt&quot;&gt;,那么所有的class都会以tt-开头\n\n\n\n自定义过渡class\n自定义class的优先级高于普通的类名，可以使用第三方动画库的类名。 使用Animate.css 需要手动加上 animate__animated 动画时间类名 \n\n\nenter-from-class\n\nenter-active-class\n\nenter-to-class\n\nleave-from-class\n\nleave-active-class\n\nleave-to-class\n&lt;transition    enter-active-class=&quot;animate__animated animate__backInDown&quot;    leave-active-class=&quot;animate__animated animate__backOutUp&quot;&gt;      &lt;h2 v-if=&quot;isShow&quot;&gt;Hello World!&lt;/h2&gt;&lt;/transition&gt;\n\njs动画钩子\nbefore-enter\nenter\nafter-enter\nbefore-leave\nleave\nafter-leave&lt;transition    @before-enter=&quot;beforeEnter&quot;    @enter=&quot;enter&quot;    @after-enter=&quot;afterEnter&quot;    @before-leave=&quot;beforeLeave&quot;    @leave=&quot;Leave&quot;    @after-leave=&quot;afterLeave&quot;&gt;    &lt;h2 v-if=&quot;isShow&quot;&gt;Hello World!&lt;/h2&gt;&lt;/transition&gt;\n\nvue脚手架配置代理方法一  在vue.config.js中添加如下配置：\ndevServer:&#123;  proxy:&quot;http://localhost:5000&quot;  // 要访问的接口地址(只写到端口)&#125;// 发送请求时axios.get(&quot;/school&quot;).then()\n说明：\n\n优点：配置简单，请求资源时直接发给前端(8080)即可\n缺点：不能配置多个代理，不能灵活的控制请求是否走代理\n工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）\n\n方法二  编写vue.config.js配置具体代理规则：\nmodule.exports = &#123;  devServer:&#123;    proxy:&#123;      &#x27;/api1&#x27;: &#123;  //匹配所有以&#x27;/api1&#x27;开头的请求路径        target:&#x27;http://localhost:5000&#x27;, // 代理目标的基础路径        changeOrigin:true,        pathRewrite: &#123; &#x27;^/api1&#x27;: &#x27;&#x27; &#125;      &#125;,      &#x27;/api2&#x27;: &#123;  //匹配所有以&#x27;/api1&#x27;开头的请求路径        target:&#x27;http://localhost:5001&#x27;, // 代理目标的基础路径        changeOrigin:true,        pathRewrite: &#123; &#x27;^/api2&#x27;: &#x27;&#x27; &#125;      &#125;    &#125;  &#125;&#125;/*    changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000    changeOrigin设置为false时，服务器收到的请求头中的host为：localhost：8080    changeOrigin默认值为true*/// 发送请求时axios.get(&quot;/api/students&quot;).then()\n\n说明：\n\n优点：可以配置多个代理，且可以灵活地控制请求是否走代理\n配置略为繁琐。请求资源时必须要加前缀\n\n插槽\n作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信，适用于 父组件 ===&gt; 子组件 。\n\n分类：默认插槽、具名插槽、作用域插槽\n\n使用方式：\n\n默认插槽：\n父组件中：        &lt;Category&gt;            &lt;div&gt;html结构&lt;/div&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;!-- 定义插槽 --&gt;                &lt;slot&gt;默认值，当使用者没有传递具体结构时，标签内的内容会展示在页面上&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n具名插槽：\n父组件中：        &lt;Category&gt;            &lt;template slot=&quot;a&quot;&gt;                &lt;div&gt;html结构&lt;/div&gt;            &lt;/template&gt;            &lt;template slot:b&gt;                &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;!-- 定义插槽 --&gt;                &lt;slot name=&quot;a&quot;&gt;默认值，当使用者没有传递具体结构时，标签内的内容会展示在页面上&lt;/slot&gt;                &lt;slot name=&quot;b&quot;&gt;默认值，当使用者没有传递具体结构时，标签内的内容会展示在页面上&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n作用域插槽：\n\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用节决定。（games数据在Category组件中，但使用数据所遍历出来的结构由父组件决定）\n具体代码：父组件中：        &lt;Category&gt;            &lt;!-- scope 是一个对象，里面存放着子组件通过插槽传过来的数据 --&gt;            &lt;template scope=&quot;scopeData&quot;&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;game in scopeData.games&quot; :key=&quot;game&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;!-- 接收数据时可使用解构语法 --&gt;            &lt;template scope=&quot;&#123; games &#125;&quot;&gt;                &lt;h4 v-for=&quot;game in games&quot; :key=&quot;game&quot;&gt; &#123;&#123;game&#125;&#125;&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;        &lt;script&gt;          export default&#123;            name:&#x27;Category&#x27;,            data()&#123;              return &#123;                games:[&quot;双人成行&quot;, &quot;小小梦魇&quot;, &quot;冒险岛&quot;, &quot;魂斗罗&quot;]              &#125;            &#125;          &#125;        &lt;/script&gt;\n\n\n\n\n\nVuex概念  在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信\n何时使用？  多个组件需要共享数据时\n搭建vuex环境\n创建文件：src/store/index.js// 引入Vue核心库import Vue from &#x27;vue&#x27;// 引入Vueximport Vuex from &#x27;vuex&#x27;// 应用Vuex插件Vue.use(Vuex)// 准备actions对象 ———— 响应组件中用户的动作const actions = &#123;&#125;;// 准备mutations对象——修改state中的数据const mutations = &#123;&#125;;// 准备state对象——保存具体的数据const state = &#123;&#125;;//创建并暴露storeexport default new Vuex.Store(&#123;  actions,  mutations,  state&#125;)\n在main.js中创建vm时传入store配置项...// 引入storeimport store from &#x27;./store&#x27;...// 创建vmnew Vue(&#123;  el:&#x27;#app&#x27;,  render: h =&gt; h(App)，  store&#125;)\n\n基本使用\n初始化数据、配置actions、配置mutations，操作文件stroe/index.js// 引入vue核心库import Vue from &#x27;vue&#x27;// 引入vueximport Vuex from &#x27;vuex&#x27;// 应用VuexVue.ues(Vuex)const actions = &#123;  // 响应组件中加法的动作  jia(context, value)&#123;    context.commit(&#x27;JIA&#x27;,value);  &#125;&#125;;const mutations = &#123;  JIA(state,value)&#123;    state.sum += value;  &#125;&#125;const state = &#123;  num: 1&#125;//创建并暴露storeexport default new Vuex.Store(&#123;  actions,  mutations,  state&#125;)\n组件中读取vuex中的数据：$store.state.num\n组件中修改vuex中的数据：$store.dispatch(&#39;actions中的方法&#39;, 数据) 或 $store.commit(&#39;mutations中的方法名&#39;, 数据)\n备注：若没有网络请求或其他业务逻辑，可以越过actions直接调用mutations，即不写dispatch,直接调用commit\n\n\n\ngetters的使用\n概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。\n在store.js中追加getters配置......const getters = &#123;  bigNum(state)&#123;    return state.num * 10  &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;  ......  getters&#125;)\n组件中读取数据：$store.getters.bigNum\n\n四个map方法的使用\nmapState方法：用于映射state中的数据为计算属性\ncomputed:&#123;  // 借助mapState生成计算属性：num、school、subject（对象写法）  ...mapState(&#123;num:&#x27;num&#x27;, school:&#x27;school&#x27;, subject:&#x27;subject&#x27;&#125;),  // 借助mapState生成计算属性：num、school、subject（数组写法）  ...mapState([&#x27;num&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;])&#125;\nmapGetters方法：用于映射getters中的数据为计算属性\ncomputed:&#123;  // 借助mapGetters生成计算属性: bigNum(对象写法)  ...mapGetters(&#123;bigNum:&#x27;bigNum&#x27;&#125;)  // 借助mapGetters生成计算属性: bigNum(数组写法)  ...mapGetters([&#x27;bigNum&#x27;])&#125;\nmapActions方法：用于生成与actions对话的方式，即包含$store.dispatch(xxx)的函数\nmethods:&#123;  // 靠mapActions生成：incrementOdd、incrementWait（对象形式）  ...mapActions(&#123; incrementOdd:&#x27;jiaOdd&#x27;, incrementWait:&#x27;jiaWait&#x27; &#125;)  // 靠mapActions生成：jiaOdd、jiaWait（数组形式）  ...mapActions([&#x27;jiaOdd&#x27;, &#x27;jiaWait&#x27;])&#125;\nmapMutations方法：用于生成与mutations对话的方法，即包含$store.commit(xxx)的函数\n// 靠mapActions生成：increment、decrement（对象形式）...mapMutations(&#123; increment:&#x27;JIA&#x27;, decrement:&#x27;JIAN&#x27; &#125;)// 靠mapMutations生成：JIA、JIAN（对象形式）...mapMutations([ &#x27;JIA&#x27;, &#x27;JIAN&#x27; ])\n\n\n备注：mapActions与mapMutations使用时，如果要传递参数 需要在模板中绑定事件时传递参数，否则参数是事件对象。\n\n模块化 + 命名空间\n目的：让代码更好维护，让多种数据分类更加明确。\n\n修改: store.js\nconst countAbout = &#123;  namespaced: true, // 开启命名空间  state:&#123; ... &#125;,  mutations:&#123; ... &#125;,  actions:&#123; ... &#125;,  getters:&#123;    bigNum(state)&#123;      return state.sum * 10    &#125;  &#125;&#125;const personAbout = &#123;  namespaced: true, // 开启命名空间  state:&#123; ... &#125;,  mutations:&#123; ... &#125;,  actions:&#123; ... &#125;&#125;export default  new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)\n开启命名空间后，组件中读取state数据：\n// 方式一：自己直接读取this.$store.state.personAbout.list// 方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;, [&#x27;num&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;])\n开启命名空间后，组件中读取getters数据：\n// 方式一：自己直接读取//                    命名空间名  /  属性名this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]// 方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;, [&#x27;bigSum&#x27;])\n开启命名空间后，组件中调用dispatch\n //方式一：自己直接dispatch//                      命名空间名  /  方法名       , 参数 this.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person) //方式二：借助mapActions： ...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\n开启命名空间后，组件中调用commit\n //方式一：自己直接commit//                    命名空间名  /  方法名    , 参数 this.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person) //方式二：借助mapMutations： ...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\n\n路由\n理解：一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n前端路由：key是路径，value是组件。\n\n基本使用\n安装vue-router ：npm i vue-router\nmain.js中引入VueRouter: import VueRouter from &#39;vue-router&#39;\n应用插件：Vue.use(VueRouter)\n编写router配置项：/*  src/router/index.js  该文件专门用于创建整个应用的路由器*///引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入路由 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;// 创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;  routes:[    &#123;      path:&#x27;/home&#x27;,      component:Home    &#125;,    &#123;      path:&#x27;/about&#x27;,      component:About    &#125;  ]&#125;)export default router\n实现切换（active-class可配置高亮样式）&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n指定展示位置&lt;router-view&gt;&lt;/router-view&gt;\n\n几个注意点\n路由组件通常放在pages/views文件夹，一般组件通常放在components文件夹。\n通过切换，“隐藏”了的路由组件，默认是销毁掉的，需要的时候再去挂载。\n每个组件都有自己的$route属性，里面存储着自己的路由信息。\n整个应用只有一个router，可以通过组件的$router属性获取到。\n\n多级路由（多级路由）\n配置路由规则，使用children配置项：router:[  &#123;    path:&#x27;/about&#x27;,    component:About  &#125;,  &#123;    path:&#x27;/home&#x27;,    component:Home,    children:[  // 通过children配置子集路由      &#123;        path:&#x27;news&#x27;,  // 子级路由一定不要写斜线，不要写成&#x27;/news&#x27;        component: News      &#125;,      &#123;        path:&#x27;message&#x27;, // 子级路由一定不要写斜线!!!        component: Message      &#125;    ]  &#125;]\n跳转（要写完整的路径,从一级路由一级一级向下找）：&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;\n\n路由的query参数\n传递参数&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link to=&quot;/home/message/detail?id=666&amp;msg=hello&quot;&gt;&lt;/router-link&gt;&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link   :to=&quot;&#123;    path:&#x27;/home/message/detail&#x27;,    query:&#123;      id:666,      msg:&#x27;hello&#x27;    &#125;  &#125;&quot;&gt;跳转&lt;/router-link&gt;\n接受参数：$route.query.id$route.query.msg\n特别注意：若传递的参数是对象，页面刷新后数据会丢失，传参时可以使用JSON.stringify()避免该问题, 普通值不会丢失\n\n命名路由\n作用：可以简化路由的跳转\n如何使用\n给路由命名：&#123;  path:&#x27;/demo&#x27;,  component:Demo,  children:[    &#123;      path:&#x27;test&#x27;,      component:Test,      children:[        &#123;          name:&#x27;hello&#x27;,  // 给路由命名          path:&#x27;welcome&#x27;,          component: Hello        &#125;      ]    &#125;  ]&#125;\n简化跳转&lt;!-- 简化前，需要写完整路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!-- 简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!-- 简化写法配合传递参数 --&gt;&lt;router-link  :to=&#123;    name:&#x27;hello&#x27;,    query:&#123;      id:666,      msg:&#x27;hello&#x27;    &#125;  &#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n路由的params参数\n配置路由，声明接收params参数&#123;  path:&#x27;/home&#x27;,  component:Home,  children:[    &#123;      path:&#x27;news&#x27;,      component:News    &#125;,    &#123;      path:&#x27;message&#x27;,      component:Message,      children:[        &#123;          name:&#x27;detail&#x27;,          path:&#x27;detail/:id/:msg&#x27;,  // 使用占位符声明接收params参数          component: Detail        &#125;      ]    &#125;  ]&#125;\n传递参数&lt;!-- 跳转并携带params写法，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/hello&quot;&gt;跳转&lt;/router-link&gt;&lt;!-- 跳转并携带params写法，to的字符串写法 --&gt;&lt;router-link  :to=&quot;&#123;    name:&#x27;detail&#x27;,    params:&#123;      id:666,      msg:&#x27;hello&#x27;    &#125;  &#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n特别注意： 路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置项\n\n\n接收参数：$route.params.id$route.params.msg\n特别注意：若传递的参数是对象，页面刷新后数据会丢失，传参时可以使用JSON.stringify()避免该问题, 普通值不会丢失\n\n路由的props配置  作用：让路由组件更方便的接收到参数\n&#123;  name:&#x27;detail&#x27;,  path:&#x27;detail/:id&#x27;,  component:Detail,  // 第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件  //  props: &#123; a:1 &#125;  // 第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件  // 缺点: 不能接受query参数  // props: true  // 第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件  props(route)&#123;    return &#123;      id:route.query.id,      msg: route.query.msg    &#125;  &#125;  /* props(&#123; query &#125;) &#123;    return &#123;      id: query.id,      title: query.title    &#125;  &#125; */  /* // 解构赋值连续写法  props(&#123; query: &#123; id, title &#125; &#125;) &#123;    return &#123;      id: id,      title: title    &#125;  &#125; */&#125;\n\n&lt;router-link&gt; 的replace属性\n作用：控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写法： 分别为push和replace，push 是追加历史记录，replace是替换当前记录。路由跳转的时候默认为push\n如何开启replace模式： &lt;router-link replace ......&gt;跳转&lt;/router-link&gt;\n\n编程式路由导航\n作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更灵活\n具体编码：// $router 的APIthis.$router.push(&#123;  name:&#x27;detail&#x27;,  params:&#123;    id:&#x27;xxx&#x27;,    msg:&#x27;xxx&#x27;  &#125;&#125;)this.$router.replace(&#123;  name:&#x27;detail&#x27;,  params:&#123;    id:&#x27;xxx&#x27;,    msg:&#x27;xxx&#x27;  &#125;&#125;)this.$router.forward() // 前进this.$router.back()  // 后退this.$router.go()  //可前进也可后退\n\n缓存路由组件\n作用：让不展示的路由组件保持挂载，不被销毁\n具体编码：&lt;keep-alive :include=&quot;组件名(组件name保存的名字)&quot;&gt;  &lt;组件名&gt;&lt;/组件名&gt;&lt;/keep-alive&gt;include: string | RegExp| Array。只有名称匹配的组件会被缓存；exclude: string | RegExp| Array。任何名称匹配的组件都不会被缓存；max: number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁\n缓存组件独有的生命周期，用于捕获路由组件的激活状态\nactivated 组件激活时触发的钩子\ndeactivated 组件失活时触发的钩子\n\n路由守卫\n作用： 对路由进行权限控制\n分类： 全局守卫、独享守卫、组件内守卫\n全局守卫：// router/index.js 文件内编写// 全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach( (to, from, next)=&gt;&#123;  console.log(&#x27;beforeEach&#x27;,to,from)  if(to.meta.isAuth)&#123;  // 判断当前路由是否需要进行权限控制    // 逻辑操作    next() // 放行  &#125;else&#123;    next(&#123;name:&#x27;home&#x27;&#125;)  // 重定向    // throw new Error()  &#125;&#125;)// 全局后置守卫： 初始化时执行、每次路由切换后执行router.afterEach( (to, from)=&gt;&#123; //  to : 到哪去 ； from 从哪来     console.log(&#x27;afterEach&#x27;, to, from)  if(to.meta.title)&#123;  // 判断当前路由是否需要进行权限控制    document.title = to.meta.title  // 修改网页的title  &#125;else&#123;    document.title = &#x27;xxx&#x27;  &#125;&#125;)\n独享守卫：// router/index.js 文件内编写beforeEnter(to, from, next)&#123;  console.log(&#x27;beforeEnter&#x27;,to,from)  if(to.meta.isAuth)&#123;  // 判断当前路由是否需要进行权限控制    // 逻辑操作    next() // 放行  &#125;else&#123;    next(&#123;name:&#x27;home&#x27;&#125;)  // 重定向    // throw new Error()  &#125;&#125;\n组件内守卫：//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;\n\n路由器的两种工作模式\n对于一个url来说，什么事hash值？ ———— #及其后面的内容就是hash值\nhash值不会包含在HTTP请求中，即：hash值不会带给服务器\nhash模式：\n地址中带有#号，不美观\n若以后将地址通过第三方手机app分享，如果app校验严格，则地址会被标记为不合法\n兼容性较好\n\n\nhistory模式：\nurl地址没有 #\n兼容性与hash模式相比略差\n应用部署上线时需要后端人员支持，解决刷新页面服务端404问题\n\n\n\n","categories":["Vue"],"tags":["Vue-cli笔记"]}]