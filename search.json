[{"title":"Array常用方法","url":"/2021/06/24/Array/","content":"\n\nArrar 构造器私有方法ofArray.of()用于将参数依次转化为数组中的一项，然后返回新数组。而不管这个参数是数字还是其他\nArray.of(8.0); //[8]Array(8.0); //[empty * 8]Array.of(8.0, 5); // [8,5]Array.of(8.0,5);  // [8,5]Array.of(&#x27;8&#x27;); // [&quot;8&quot;]Array(&#x27;8&#x27;); // [&quot;8&quot;]\nfromArray.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。然后返回一个新数组，原数组不变。\n\n语法 : Array.from(arrayLike, callbackFn, thisArg)参数:\n\n\narrayLike : 必选,想要转换成数组的类数组对象或可迭代的对象\ncallbankFn : 可选,回调函数，新生成的数组会经过该函数的加工再返回\nthisArg : 可选,回调函数执行时this指向的值var arg = &#123;0:&#x27;a&#x27;,1:&#x27;b&#x27;,2:&#x27;c&#x27;, length:3&#125;;Array.from(arg, function(value)&#123;  //  value: 每项的键值  return value;  // 必须指定返回值，否则返回的新数组元素都为undefined&#125;,arg)// StringArray.from(&#x27;abc&#x27;); //[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]//SetArray.from(new Set([&#x27;abc&#x27;,&#x27;def&#x27;]));  //[&quot;abc &quot;,&quot;def&quot;]// MapArray.from(new Map([[1,&#x27;ab&#x27;],[2,&#x27;cd&#x27;]])) // [[1,&#x27;ab&#x27;],[2,&#x27;cd&#x27;]]\n不改变原数组的方法concat()concat() 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。[&#x27;hello&#x27;].concat([&#x27;world&#x27;])// [&quot;hello&quot;, &quot;world&quot;][&#x27;hello&#x27;].concat([&#x27;world&#x27;], [&#x27;!&#x27;])// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;]\njoin()join()方法将一个数组(或一个类数组对象)的所有元素连接成一个字符串，并返回这个字符串。如果数组只有一个项目，那么将直接返回该项目而不使用分隔符；如果没有传参，分隔符默认为逗号。var arr = [&#x27;Fire&#x27;,&#x27;Air&#x27;,&#x27;Water&#x27;];arr.join() // &quot;Fire,Air,Water&quot;arr.join(&#x27;&#x27;) // &quot;FireAirWater&quot;\nslice()slice()方法返回一个新数组，这一对象是一个由begin和end决定的原数组的浅拷贝(包括begin,不包括end).原数组不会被改变var arr = [1,2,3,4,5];arr.slice(2) //  [3,4,5]arr.slice(2,4) //[3,4]\ntoString()toString()返回一个字符串，表示指定的数组及元素[1,2,&#x27;a&#x27;,&#x27;b&#x27;].toString()//  &quot;1,2,a,b&quot;\nindexOf()indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。第一个参数为要查找的元素（必选）， 第二个参数是开始查询的位置（可选）var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;c&#x27;];arr.indexOf(&#x27;c&#x27;) // 2arr.indexOf(&#x27;c&#x27;,3) // 4\n\n改变原数组的方法pop()pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。\nvar arr = [1,2,3,4,5]console.log(arr.pop()) // 5console.log(arr)  // [1,2,3,4]\npop()原理Array.prototype.pop = function()&#123;  let arr = this,    len = arr.length;  if(len == 0)&#123;    return undefined;  &#125;  len--;  let value = arr[len];  delete arr[len]  arr.length = len;  return value;&#125;\npush()push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\nvar arr = [1,2,3,4,5]console.log(arr.push(1)) // 6console.log(arr)  // [1,2,3,4,5,1]\npush()原理Array.prototype._push = function(...items)&#123;  let arr = this,    len = arr.length,    argLen = items.length;  for(let i=0;i&lt;argLen;i++)&#123;    arr[len+i] = items[i]  &#125;  let newLength = len+argLen;  arr.length = newLength;  return newLength&#125;\nreverse()reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。\nvar arr = [1,2,3,4,5]console.log(arr.reverse()) // [5,4,3,2,1]console.log(arr)  // [5,4,3,2,1]\nsplice()splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。\nvar arr = [1,2,3,4,5]console.log(arr.splice(0,1)) // [1] 返回被删除的元素console.log(arr)  // [2,3,4,5]console.log(arr.splice(0,0,&#x27;add1&#x27;)) //[] 空数组console.log(arr)  // [&#x27;add1&#x27;,1，2,3,4,5]console.log(arr.splice(0,1,&#x27;add2&#x27;)) //[1] 返回被替换的元素console.log(arr)  // [&#x27;add2&#x27;，2,3,4,5]\nshift()shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\nvar arr = [1,2,3,4,5]console.log(arr.shift()) // 返回删除元素的值console.log(arr)  // [2,3,4,5]\nunshift()unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。\nvar arr = [1,2,3]console.log(arr.unshift(0,1,2)) // 6  返回该数组的新长度console.log(arr)  // [0,1,2,1,2,3]\nsort()sort() 方法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的，该方法改变原数组\n// 默认排序var arr = [8,16,50,6,100]console.log(arr.sort()) // [100, 16, 50, 6, 8]// 升序var arr = [8,16,50,6,100]console.log(arr.sort( function(a,b)&#123; return a-b &#125;)) // [5, 8, 16, 50, 100]// 降序var arr = [8,16,50,6,100]console.log(arr.sort( function(a,b)&#123; return b-a &#125;)) // [100,50,16,8,5]\n\n\n迭代方法遍历类型的方法最后返回的都是一个新数组。并不会改变原有数组的值\nforEach()forEach()方法用于调用数组的每一个元素，并将元素传递给回调函数。\n\n语法: array.forEach( callback(currentValue, index, array),thisArg)\n\n\ncallback: 为数组中每个元素执行的函数，该函数接收一至三个参数\ncurrentValue : 必填,当前元素\nindex : 可选,当前元素的索引值\narr : 可选,当前元素所属的数组对象\nthisArg : 可选,传递给函数的this值,如果参数为空,当前回调函数this指向window注意:1、forEach()对于空数组不会执行回调函数.2、for循环可以用continue跳过循环中的一个迭代，forEach()用continue会报错3、forEach()需要用return 跳过循环中的一个迭代，跳过之后会执行下一个迭代var arr = [1,2,3];for(var i=0;i&lt;arr.length;i++)&#123;  if(arr[i] == 2)&#123;    continue;  &#125;  console.log(arr[i]) // 1  3&#125;arr.forEach( function(value)&#123;  if(value == 2)&#123;    return;  &#125;  console.log(value)// 1  3&#125;)\nforEach原理Array.prototype._forEach = function(fn,thisArg)&#123;  if(!thisArg)&#123;    for(var i = 0; i&lt;this.length; i++)&#123;      fn(this[i],i,this)    &#125;  &#125;else&#123;    for(var i = 0; i&lt;thisArg.length; i++)&#123;      fn.call(thisArg,thisArg[i],i,thisArg)    &#125;  &#125;&#125;\n\n\n\nevery()every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试，返回一个布尔值。\n\n语法 : arr.every(callback(value, index, array), thisArg)\n\n[1,2,3].every( (value) =&gt; Number.isInteger(value) );  // true\n可以将every()方法看做一个等价于逻辑与的数组\nevery 实现原理为每个值执行回调，如果在任何时候返回false，则退出循环，整个方法返回false。如果循环终止都没有进入到if语句，说明每个条件都成立，则方法返回true\nArray.prototype._every = function(callback)&#123;  var arr = this,    len = arr.length;  for(var i = 0; i&lt;len;i++)&#123;    var value = arr[i];    if(!callback(value, i, arr))&#123;      return false;    &#125;  &#125;  return true;&#125;\nsome()some()方法every()刚好相反，即只要其中一个为true就会返回true。与every方法类似，可以将some方法看做一个等价的逻辑或数组\nsome 实现原理Array.prototype._some = function(callback)&#123;  var arr = this,    len = arr.length;  for(var i = 0; I&lt;len; i++)&#123;    var value = arr[i];    if(callback(value,i,arr))&#123;      return true;    &#125;  &#125;  return false&#125;\nfilter()filter() 方法创建一个新数组, filter会把传入的函数依次作用于每个元素，然后根据返回值是 true 还是false决定保留还是丢弃该元素。用于把Array的某些元素过滤掉，然后将剩下的元素放入新数组中返回。\n\n语法: var newArr = arr.filter(callback(element, index, array),thisArg)参数: \n\n\ncallback : 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留\nelement : 数组中正在处理的元素\nindex : 正在处理的元素在数组中的索引\narray : 当前调用filter的数组本身\n\n\nthisArg : 改变回调函数中this的指向filter()的原理Array.prototype._filter = function(callbackFn,thisArg)&#123;  if(Object.prototype.toString.call(callbackFn) !== &#x27;[object Function]&#x27;)&#123;    throw new TypeError(callbackFn + &#x27;is not a function&#x27;)  &#125;  var arr = this,     len = arr.length,    newArr=[];  for(var i = 0; i&lt;len; i++)&#123;    if(callbackFn(arr[i],i,arr))&#123;      newArr.push(arr[i])    &#125;  &#125;  return newArr;&#125;\n\nmap()\nmap() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\n\n\n语法: var newArr = array.map( function(currentValue, index, arr),thisArg)参数同forEach()\n\nmap()原理Array.prototype._map = function(callbackFn, thisArg)&#123;  if(this === null || this === undefined)&#123;    throw new TypeError(&quot;Cannot read property &#x27;_map&#x27; of null&quot;)  &#125;  if(Object.prototype.toString.call(callbackFn)!= &#x27;[object Function]&#x27;)&#123;    throw new TypeError(callbackFn+&#x27;is not a function&#x27;)  &#125;  let arr = this,    len = arr.length,    newArr = new Array(len);    for(let i = 0; i&lt;len; i++)&#123;      if(i in arr)&#123;        let kValue = arr[i];        let mappedValue = callbackFn.call(thisArg,kValue,i,arr)        newArr[i] = mappedValue;      &#125;    &#125;    return newArr;&#125;var a = [1, 2, 3]var b = a._map(function (item, i, arr) &#123;  return item * 2;&#125;)console.log(b);  //[2,4,6]\nreduce()reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\n语法 : var result = arr.reduce(callback(acc, cur, index, array), initValue)参数: \n\n\ncallback : 执行数组中每个值得函数,包含四个参数\nacc : 必选,initvalue提供的初始值,或者是 上一次电用的返回值(可以理解为收集箱,收集每次调用后的返回值)\ncur : 必选,数组中当前被处理的元素\nindex : 可选,当前元素的索引\narray : 可选,调用reduce()的数组\n\n\ninitValue : 可选,作为第一次调用时 callback的第一个参数\n\nreduce()原理Array.prototype._reduce = function(callbackFn, initValue)&#123;  // 异常处理，和map类似  if(this === null || this === undefined)&#123;    throw new TypeError(&quot;Cannot read property &#x27;_reduce&#x27; of null&quot;)  &#125;  // 处理回调类型异常  if(Object.prototype.toString.call(callbackFn)!= &#x27;[object Function]&#x27;)&#123;    throw new TypeError(callbackFn+&#x27;is not a function&#x27;)  &#125;  let arr = this,    // 判断是否传入初始值，如果没有，初始值为当前数组的第一位,否则以传入的值当做初始值    acc = arguments.length === 1 ? arr[0] : initValue,    // 若没有传入初始值，数组第一位为初始值，所以遍历要从第二位开始，也就是下标为1的位置    startIdx = arguments.length === 1 ? 1 : 0;   for(var i = startIdx; i&lt;arr.length; i++)&#123;    acc = callbackFn(acc,arr[i],i,arr);  &#125;  return acc&#125;\n\n","categories":["javascript","Array"],"tags":["数组常用方法"]},{"title":"LazyFunction","url":"/2021/06/03/LazyFunction/","content":"惰性函数\n普通函数\ntimeStamp 污染全局\n执行第一次之后，timeStamp 已经有值，但后续每次执行都会进入 if 语句// 例：var timeStamp = null;function getTimeStamp() &#123;  if (timeStamp) &#123;    return timeStamp  &#125;  timeStamp = new Date().getTime();  return timeStamp&#125;;\n惰性函数\n执行一遍外层函数，拿到需要的值后，在函数内部重写自身，返回需要的值\n后续调用 不需要每次都执行原函数 重读的代码段// 例：var getTimeStamp = function () &#123;  let timeStamp = new Date().getTime();  getTimeStamp = function () &#123;    return timeStamp;  &#125;  return getTimeStamp();&#125;\n实际应用\n\n普通函数添加事件\n每次执行都要对浏览器进行判断。 可以在第一次判断后就保留判断结果，再次执行时就不需要判断了。\n\nvar addEvent = (function () &#123;  if (window.addEventListener) &#123;    return function (el, type, fn, capture) &#123;      el.addEventListener(type, fn, capture);    &#125;  &#125; else if (window.attachEvent) &#123;    return function (el, type, fn) &#123;      el.attachEvent(&#x27;on&#x27; + type, function () &#123;        fn.call(el)      &#125;)    &#125;  &#125; else &#123;    return function (el, type, fn) &#123;      el[&#x27;on&#x27; + type] = fn;    &#125;  &#125;&#125;)();\n惰性函数添加事件\n第一次判断之后，在函数体内部重写自身，后续执行的是重写后的函数，不需要再进行无用的判断\n\nvar addEvent = function (el, type, fn, capture) &#123;  if (el.addEventlistener) &#123;    addEvent = function (el, type, fn, capture) &#123;      el.addEventlistener(type, fn, capture)    &#125;  &#125; else if (el.attachEvent) &#123;    addEvent = function (el, type, fn) &#123;      el.attachEvent(&#x27;on&#x27; + type, function () &#123;        fn.call(el)      &#125;)    &#125;  &#125; else &#123;    addEvent = function (el, type, fn) &#123;      el[&#x27;on&#x27; + type] = fn    &#125;  &#125;  return addEvent(el, type, fn, capture);&#125;\n\n","categories":["javascript","function"],"tags":["高阶函数"]},{"title":"Symbol.iterator & 生成器函数","url":"/2021/05/31/Symbol-iterator/","content":"生成器、迭代器\n\n给对象添加迭代器属性let obj = &#123;  a:1,  b:2,  c:3,  [Symbol.iterator]: function()&#123;    var index = 0;    let map = new Map();    // 把当前对象转换为Map对象    for(var key in this)&#123;      map.set(key, this[key])    &#125;    // map.keys()  键名    // map.values() 键值    // mao.entries() 键值对    return &#123;      next()&#123;        // 拿到每个键值对形成的数组        // console.log(map.entries())  =&gt; &#123;&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3&#125;        var mapEntries = [...map.entries()];        // mapEntries = [[&quot;a&quot;, 1],[&quot;b&quot;, 2],[&quot;c&quot;, 3]]        if(index &lt; map.size)&#123;          // 只要当前位置比对象的长度小 就返回打散后的map对象的当前下标的值和值为false                    // done 代表是否迭代完成          return &#123;            value:mapEntries[index++],            done:false          &#125;        &#125;        // 否则返回的值为 undefined  done为true        return &#123; value:undefined, done:true &#125;      &#125;    &#125;  &#125;&#125;\n\n生成器函数\n每次调用next函数时，只会执行到下一个yield，之后的代码不会执行。\n\nfunction* test()&#123;  let value1 = yield 1;  console.log(value1);  // &#x27;two&#x27;  let value2 = yield 2;    console.log(value2);  // &#x27;three&#x27;    let value3 = yield 3;    console.log(value3);  // &#x27;four&#x27;    let value4 = yield 4;    console.log(value4);  // undefined&#125;var iter = test();// 第一次调用传值不会被接收，第二次传值时会传递给第一个yield位置的变量  第三次传值 -&gt; 第二个yield  以此类推console.log(iter.next(&#x27;one&#x27;));  //  &#123;value: 1, done: false&#125;console.log(iter.next(&#x27;two&#x27;));  //  &#123;value: 2, done: false&#125;console.log(iter.next(&#x27;three&#x27;));  //  &#123;value: 3, done: false&#125;console.log(iter.next(&#x27;four&#x27;));  //  &#123;value: 4, done: false&#125;console.log(iter.next());  //  &#123;value: undefined, done: true&#125;\n\n使用生成器函数编写迭代器var obj = &#123;  a:1,  b:2,  c:3,  [Symbol.iterator]: function* () &#123;    var index = 0;    let map = new Map();    for(var key in this)&#123;      map.set(key, this[key])    &#125;    var mapEntries = [...map.entries()];    // 循环生成yield    while(index &lt; mapEntries.length)&#123;      yield mapEntries[index++];    &#125;  &#125;&#125; // for of  底层相当于调用了 obj[Symbol.iterator].next().valuefor (var i of obj) &#123;   console.log(i); // [&quot;a&quot;, 1]  [&quot;b&quot;, 2]  [&quot;c&quot;, 3]  undefined&#125;\n\n\n\n","categories":["javascript","function"],"tags":["生成器、迭代器"]},{"title":"Vue笔记","url":"/2021/08/10/Vue%E7%AC%94%E8%AE%B0/","content":"\n\n\n编码时需要注意的问题\n被Vue管理的函数最好写成普通函数，以保证this的指向是vm或组件的实例对象\n不被Vue管理的函数（定时器的回调函数、ajax的回调函数、Promise的回调函数等），最好写成箭头函数，这样this的指向才是vm或组件的实例对象\n\nVue中的MVVM模型\nM: 模型(Model): data中的数据\n\nV: 视图(View) : 模板代码\n\nVM: 视图模型(ViewModel) : Vue实例\n\n\n结果: ① data中所有的属性,最后都出现在了Vue的实例vm身上;\n   ② vm身上所有的属性及Vue原型上所有的属性,在Vue的模板中都可以直接使用\nVue中的数据代理\nVue中的数据代理是通过vm对象代理data对象中属性的操作(读/写)\n基本原理：\n\n① 通过Object.defineProperty()把data对象中所有属性添加到vm上。\n② 为每一个添加到vm上的属性，都指定一个getter/setter。\n③ 在getter/setter内部去操作(读/写) data中对应的数据\n\nVue中的事件事件的基本使用\n使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名。\n事件的回调需要配置在methods对象中，最终会在vm上。\nmethods中配置的函数，不要用箭头函数！否则this就不指向vm了。\nmethods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象。\n@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传其他参数。\n\n事件修饰符\nprevent：阻止默认事件\nstop：阻止事件冒泡\nonce：事件只触发一次\ncapture：使用事件的捕获模式\nself：只有event.target是当前操作的元素时才触发事件\npassive：事件的默认行为立即执行，无需等待事件回调执行完毕\n\n键盘事件（常用的按键别名）\n回车 =&gt; enter  删除 =&gt; delete (捕获“删除”和“退格”键)  退出 =&gt; esc  空格 =&gt; space  换行 =&gt; tab (特殊，必须配合keydown去使用)  上 =&gt; up  下 =&gt; down  左 =&gt; left  右 =&gt; right\n\n计算属性computed\n\n用途： 要使用的数据需要通过已有的属性加工后得来\n原理：底层借助了Objcet.defineproperty方法提供的getter和setter\nget函数什么时候执行？ (1).初次读取时会执行一次 (2).当依赖的数据发生改变时会被再次调用\n与methods实现相比，内部有缓存机制（复用），效率更高，调试方便\n计算属性最终会出现在vm上，直接读取使用即可\n如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\n\n\ndata()&#123;  return &#123;    firstName:&#x27;&#x27;,    lastName:&#x27;&#x27;  &#125;&#125;//完整写法fullName:&#123;  get()&#123;    console.log(&#x27;get被调用了&#x27;)    return this.firstName + &#x27;-&#x27; + this.lastName  &#125;,  set(value)&#123;    console.log(&#x27;set&#x27;,value)    const arr = value.split(&#x27;-&#x27;)    this.firstName = arr[0]    this.lastName = arr[1]  &#125;&#125;// 简写fullName()&#123;  console.log(&#x27;get被调用了&#x27;)  return this.firstName + &#x27;-&#x27; + this.lastName&#125;\n\n监视属性watch\n当被监视的属性存在变化时，回调函数自动调用，进行相关操作\nwatch默认不监测对象内部值得改变，可通过配置deep:true监测深层数据的变化data()&#123;  return &#123;    isHot:true  &#125;&#125;,watch:&#123;  // 完整写法  isHot:&#123;    immediate: true,  // 初始化时执行一次回调函数    deep: true,  // 开启深度监听    handler(newValue, oldValue)&#123;      /* 函数体逻辑 */    &#125;   &#125;  // 简写  isHot(newValue, oldValue)&#123;    /* 函数体逻辑 */  &#125;&#125;\n\ncomputed和watch之间的区别compouted能完成的功能，watch都可以完成。watch能完成的computed不一定能完成，例如：watch可以发送异步请求\n绑定样式class样式\n写法：:class=&#39;xxx&#39;xxx可以是字符串、数组、对象\n字符串写法适用于：类名不确定，要动态获取。\n对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n\n\n\n  &lt;div :class=&quot;mood +&#x27; &#x27;+ font&quot;&gt;字符串写法&lt;/div&gt;&lt;div :class=&quot;classArr&quot;&gt;数组写法&lt;/div&gt;&lt;div :class=&quot;classObj&quot;&gt;对象写法&lt;/div&gt;  data()&#123;    return &#123;      mood: &#x27;normal&#x27;,      font: &#x27;font&#x27;,      classArr: [&#x27;class1&#x27;, &#x27;class2&#x27;, &#x27;class3&#x27;],      classObj: &#123;        class1: false,        class2: false,      &#125;,    &#125;  &#125;\n\nstyle样式\n写法: :style=&quot;&#123;fontSize: xxx&#125;&quot;  或 :style=&quot;[a,b]&quot; &lt;div :style=&quot;&#123;font-size:40px&#125;&quot;&gt;对象写法&lt;/div&gt; &lt;div :style=&quot;[&#123;font-size:40px&#125;,&#123;color:#000&#125;]&quot;&gt;数组写法&lt;/div&gt;\n\n条件渲染v-if写法：\n  (1).v-if=&quot;表达式&quot; \n  (2).v-else-if=&quot;表达式&quot;\n  (3).v-else=&quot;表达式&quot;\n适用于：切换频率较低的场景。\n特点：不展示的DOM元素直接被移除。\n注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”\n\nv-show写法：v-show=&quot;表达式&quot;\n适用于：切换频率较高的场景。\n特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\n\n列表渲染v-for指令：\n\n用于展示列表数据\n语法： v-for=&quot;(item, index) in xxx&quot; :key:&quot;yyy&quot;    3. 可用于遍历 数组、对象、字符串、指定次数      \n\n双向绑定\n收集表单数据：  若：&lt;input type=&quot;text&quot;/&gt;    ，则v-model收集的是value值，用户输入的就是value值。  若：&lt;input type=&quot;radio&quot;/&gt;    ，则v-model收集的是value值，且要给标签配置value值。  若：&lt;input type=&quot;checkbox&quot;/&gt;          1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）      2.配置input的value属性:      &emsp;&emsp;(1).v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）      &emsp;&emsp;(2).v-model的初始值是数组，那么收集的的就是value组成的数组\n\n  备注：v-model的三个修饰符：\n\nlazy：失去焦点再收集数据\nnumber：输入字符串转为有效的数字\ntrim：输入首尾空格过滤\n\n过滤器定义：对要显示的数据进行特定的格式化后再显示(适用于一些简单逻辑的处理)。语法：\n\n注册过滤器：Vue.filter(name, callback) 或在组件的配置对象中直接写 &#123; ..., filters:&#123;name(value)&#123; return... &#125;&#125;&#125;\n使用过滤器： &#123;&#123; xxx| 过滤器名 &#125;&#125;  或  v-bind:属性=&quot;xxx | 过滤器名&quot;备注：\n过滤器可以接受额外参数，多个过滤器可以串联。\n不会改变原数据，产生新的对应的数据// 全局过滤器Vue.filter(&#x27;mySlice&#x27;, function(value)&#123;  return value.slice(0,4)&#125;)// 全局过滤器使用方式&#123;&#123;msg | mySlice&#125;&#125;  ||  :x=&quot;msg | mySlice&quot;/*********************************************/// 局部过滤器&#123;  data,  methods,  filters:&#123;    timeFormater(value, str=&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123;      return dayjs(valaue).format(str)    &#125;  &#125;&#125;// 多个参数 和 过滤器连用：&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;\n\n内置指令v-text\n作用：向其所在的节点中渲染文本内容。\n与插值语法的区别： v-text会替换掉节点中的内容，  则不会\n\nv-html\n作用： 向指定节点中渲染包含html结构的内容。\n与插值语法的区别：\nv-html会替换掉节点中的内容，  不会\nv-html可以识别html结构。\n\n\n需注意：v-html有安全性问题\n在网站上动态渲染HTML非常危险，容易导致XSS攻击\n一定要在可信的内容上使用v-html， 不要用在用户提交的内容上\n\n\n\nv-cloak\n特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性\n使用css配合v-cloak可以解决网速慢时页面展示出的问题\n\nv-once\nv-once所在节点在初次动态渲染后，就视为静态内容了。\n以后数据的改变不会引起v-once所在的结构更新，可以用于优化性能\n\nv-pre\n跳过其所在节点的编译过程。\n可以利用他跳过 没有使用指令语法、没有使用插值语法的节点， 会加快编译。\n\n自定义指令定义语法\n局部指令：new Vue(&#123;   directives:&#123;   //  &#x27;指令名&#x27;：&#x27;配置对象&#x27;   /**    * element : 使用当前指令的真实DOM    * binding : 自定义指令的信息对象    */   //  abc函数的的执行： 1. 指令与元素成功绑定时。 2. 指令所在的模板被重新解析时   // 简写   abc(element, binding)&#123;&#125;  ||  &#x27;a-bc&#x27;:function(element, binding)&#123;&#125;   // 完整写法     abc:&#123;       // 指令与元素成功绑定时       bind(element, binding)&#123;&#125;,       // 指令所在元素被插入页面时       inserted(element, binding)&#123;&#125;,       // 指令所在模板被重新解析时       update(element, binding)&#123;&#125;     &#125;   &#125;&#125;)\n全局指令Vue.directive(&#x27;abc&#x27;,&#123;  // 指令与元素成功绑定时  bind(element, binding)&#123;&#125;,  // 指令所在元素被插入页面时  inserted(element, binding)&#123;&#125;,  // 指令所在模板被重新解析时  update(element, binding)&#123;&#125;&#125;)\n\n生命周期钩子函数\nbeforeCreate 在实例初始化之后，在数据观测和事件配置之前被调用，这时的this还不能使用\ncreated 实例创建完成后调用，可以使用data内的数据和methods内的方法了，但dom节点还未挂载，不能对dom节点进行操作\nbeforeMount 在挂载开始之前被调用，相关的 render 函数首次被调用。\nmounted 挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行\nbeforeUpdate 数据更新前调用，发生在虚拟dom重新渲染之前，可以在这个钩子中继续更改状态，不会再次触发渲染过程\nupdated 虚拟dom渲染成真实dom之后调用，现在可以执行 依赖于本次更新数据的操作\nbeforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。\ndestroyed 实例销毁后调用。Vue 实例指示的所有东西都会解绑定，自定义事件会失效，但原生dom事件依然有效。\n\n常用的钩子\nmounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\nbeforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n\n组件Vue中使用组件的三个步骤\n定义组件(创建组件) 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样 区别如下：\n不能写el： 最终所有组件都要经过一个vm的管理，由vm中的el决定服务于哪个容器\ndata必须写成函数： 避免组件被复用时，数据存在引用关系\n组件结构的配置项为template\n\n\n注册组件 局部注册：new Vue的时候传入components选项 全局注册：Vue.component(&#39;组件名&#39;,组件)\n\n\n编写组件标签 \n\n注意点\n关于组件名: 一个单词组成： 第一种写法(首字母小写)：school\n 第二种写法(首字母大写)：School\n\n 多个单词组成： 第一种写法(kebab-case命名)：my-school\n 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)\n\n 备注： 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。\n 可以使用name配置项指定组件在开发者工具中呈现的名字。\n\n\n关于组件标签:   第一种写法：&lt;school&gt;&lt;/school&gt;   第二种写法：&lt;school/&gt;   备注：不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。\n\nVueComponent\n组件的本质是一个名为VueComponent的构造函数，这个构造函数是由Vue.extend 生成\n只需要写入 &lt;school/&gt; 或 &lt;school&gt;&lt;/school&gt;，Vue解析时会自动帮我们执行new VueComponent(options)\n每次调用Vue.extend， 返回的都是一个全新的VueComponent!\n关于this指向：\n组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。\nnew Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。— 注意 —内置关系：VueComponent.prototype.__proto__ === Vue.prototype为了让组件实例对象可以访问到Vue原型上的属性和方法\n\n\n\n","categories":["Vue"],"tags":["Vue笔记"]},{"title":"call()、apply()、bind()","url":"/2021/06/24/call/","content":"\n\ncall()call()的使用方法\n语法：function.call(thisObj, arg1, arg2, …)\n\n\n说明：call() 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果提供的thisObj参数为null或undefined时会自动替换为指向全局对象，原始值会被包装\n\nfunction Class1()&#123;  this.name = &quot;class1&quot;;  this.showName = function()&#123;    console.log(this.name);  &#125;&#125;function Class2()&#123;  this.name = &quot;class2&quot;;&#125;var c1 = new Class1();var c2 = new Class2();c1.showNam.call(c2); //class2\ncall()的意思是把c1的方法放到c2上执行，原来c2是没有showName()方法的,现在把c1的showName方法放进c2里执行，所以this.name应该是class2，执行的结果就是’class2’；call()方法实现继承\nfunction Class1()&#123;  this.showTxt = function()&#123;    console.log(txt)  &#125;&#125;function Class2()&#123;  Class1.call(this);&#125;var c2 = new Class2()c2.showTxt(&#x27;cc&#x27;)\n这样Class2就继承Class1了，Class1.call(this)的意思就是使用Class1对象代替this对象，那么Class2中就可以有了Class1的所有属性和方法了，c2对象就能够直接调用Class1的方法及属性，执行结果就是console.log(‘cc’);使用call()继承的弊端： 如果Class1后续向prototype添加了新的属性或方法，Class2拿不到新增的属性和方法\nClass1.prototype.name = &#x27;class1&#x27;console.log(c2.name) // undefined\ncall()原理js实现call\nfunction person(a, b, c, d) &#123;      return &#123;        name: this.name,        a: a, b: b, c: c, d: d      &#125;    &#125;    var yx = &#123; name: &#x27;yx&#x27; &#125;;    Function.prototype.newCall = function (obj, ...args) &#123;      var obj = obj || window;      obj.p = this;      /**       * var result = obj.p(...args);       * */       var newArgs = [];      for (var i = 0; i &lt; args.length; i++) &#123;        newArgs.push(&#x27;args[&#x27; + i + &#x27;]&#x27;)      &#125;      var result = eval(&#x27;obj.p(&#x27; + newArgs + &#x27;)&#x27;)      delete obj.p;      return result    &#125;    var bib = person.newCall(yx, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;)    console.log(bib);\napply()apply()的使用方法\n语法： function.apply(thisArg, [argArr])\n\n\n说明： apply()方法与call()方法类似。也是改变this指向(函数执行时所在的作用域)，然后在指定的作用域中，调用该函数，同时也会立即执行该函数。唯一的区别在于，apply()接受一个数组作为执行时的参数。\n\nvar obj = &#123;  name:&#x27;yx&#x27;&#125;;function test(firstName,lastName)&#123;  console.log(firstName + &#x27; &#x27; + this.name + &#x27; &#x27; + lastName);&#125;test.apply(obj,[&#x27;a&#x27;,&#x27;b&#x27;]) // a yx b\napply()原理function person(a,b,c,d)&#123;  return &#123;    name: this.name,    a:a,b:b,c:c,d:d  &#125;&#125;var yx = &#123;  name: &#x27;yx&#x27;&#125;Function.prototype.newApply = function(obj, arr)&#123;  var obj = obj || window, result;  obj.p = this;  if(!arr)&#123;    result = obj.p()  &#125;else&#123;    //  result = obj.p(...arr)    var newArgs = [];    for(var i=0; i&lt;arr.length; i++)&#123;      newArgs.push(&#x27;arr[&#x27;+ i +&#x27;]&#x27;)    &#125;    result = eval(&#x27;obj.p(&#x27;+ newArgs +&#x27;)&#x27;)  &#125;  delete obj.p  return result;&#125;var res = person.newApply(yx,[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]);\nbind()bind()使用方法\n语法: function.bind(thisArg, arg1, arg2, …)\n\n\n说明:  bind()方法主要就是将函数绑定到某个对象，bind()会创建一个函数，函数体内的this对象的值会被绑定到传入bind()中的第一个参数的值，例如：f.bind(obj)，实际上可以理解为obj.f()，这时f函数体内的this自然指向的是obj\n\nthis.num = 9;var moduleA = &#123;  num:81,  getNum ()&#123; return this.name &#125;&#125;var getNum = moduleA.getNumgetNum() //9.  因为这个这例子中this 指向全局windowvar boundGetNum = getNum.bind(moduleA)boundGetNum(); //81\nbind()原理Function.prototype.newBind = function()&#123;  const that = this;  var args = Array.prototype.slice.call(arguments);  var context = args.shift();  return function()&#123;    var arrSum = args.concat([...arguments])    return that.apply(context, arrSum)  &#125;&#125;\n\n\n\n\n\n\n","categories":["javascript","function"],"tags":["改变this指向"]},{"title":"debounce & throttle","url":"/2021/06/02/debounce/","content":"防抖、节流\n函数防抖\nn秒内只要触发事件，就重新计时，一直触发事件处理函数的程序永远不能被执行\n\n/**  *  fn  需要设置防抖的函数  *  time  执行时需要延迟的时间  *  triggleNow  是否马上触发第一次**/function test() &#123;  console.log(1);&#125;box.onmouseover = debounce(test, 1000, false);function debounce(fn, time, triggleNow) &#123;  var t = null;  var debounced = function () &#123;    var _self = this,      args = arguments;    if (t) &#123;      clearTimeout(t)    &#125;    if (triggleNow) &#123;      var exec = !t;      t = setTimeout(() =&gt; &#123;        t = null      &#125;, time)      if (exec) &#123;        fn.apply(_self, args)      &#125;    &#125; else &#123;      t = setTimeout(() =&gt; &#123;        fn.apply(_self, args)      &#125;, time)    &#125;  &#125;  debounced.remove = function () &#123;    clearTimeout(t);    t = null;  &#125;  return debounced&#125;\n\n函数节流\n事件被触发，n秒之内只执行一次事件处理函数\n\nvar input = document.getElementById(&#x27;input&#x27;);input.onkeyup = throttle(check, 1000);function check() &#123;  var val = this.value;  if (val.length &lt; 6) &#123;    console.log(&#x27;Invalid length&#x27;);  &#125; else &#123;    console.log(&#x27;success&#x27;);  &#125;&#125;function throttle(fn, delay)&#123;  var t = null,    begin = new Date().getTime();  return function()&#123;    var _self = this,      args = argumens,      cur = new Date().getTime();    clearTimeout(t);    if( cur - begin &gt;= delay )&#123;      fn.apply(_self, args);      begin = cur;    &#125;else&#123;      t = setTimeout( ()=&gt;&#123;        fn.apply(_self, args)      &#125;,delay)    &#125;  &#125;&#125;","categories":["javascript","function"],"tags":["防抖、节流"]},{"title":"js-cookie","url":"/2021/07/07/js-cookie/","content":"\n\n\n创建cookie// 创建一个cookie，在这整个站点中有效Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;);// 创建一个有效期为7天的cookie，在整个站点中有效Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;, &#123; expires: 7 &#125;);// 创建一个有效期为7天的cookie，只在当前页面生效Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;, &#123; expires: 7, path: &#x27;&#x27;  &#125;)\n\n读取cookieCookies.get(&quot;name&quot;) // =&gt; &#x27;value&#x27;Cookies.get(&quot;nothing&quot;) //=&gt; &#x27;undefined&#x27;// 读取所有可见的cookiesCookies.get() // =&gt; &#123; name: &#x27;value&#x27; &#125;\n\n删除cookieCookies.remove(&#x27;name&#x27;);// 如果设置了路径，在删除时也需指定路径// 例：Cookies.set(&#x27;name&#x27;, &#x27;value&#x27;, &#123; path:&#x27;&#x27; &#125;)// 删除不存在的cookies不会报错也没有返回Cookies.remove(&#x27;name&#x27;)  // 删除失败Cookies.remove(&#x27;name&#x27;, &#123; path:&#x27;&#x27; &#125;) // 删除成功\n\n命名空间如果担心修改掉Cookies中的数据，可以使用noConflict方法定义一个新的空间，并保留原始cookies\n// 将 js-cookie api 分配给不同的变量。恢复原来的&#x27;window.Cookies&#x27;var Cookies2 = Cookies.noConflict()Cookies2.set(&#x27;name&#x27;,&#x27;value&#x27;)\n\njson相关js-cookies允许向cookie中存储json信息通过set方法传入Array或对象，而不是简单的string，那么js-cookies会自动调用JSON.stringify将传入的数据转为json\nCookies.set(&#x27;name&#x27;, &#123; foo: &#x27;bar&#x27; &#125;);Cookies.get(&#x27;name&#x27;); // =&gt; &#x27;&#123; &quot;foo&quot;: &quot;bar&quot; &#125;&#x27;Cookies.get(); // =&gt; &#123; name: &#x27;&#123; &quot;foo&quot;: &quot;bar&quot; &#125;&#x27; &#125;\n如果用getJSON方法获取Cookies，那么js-cookies会调用JSON.parse 解析 json 后返回。\nCookies.getJSON(&#x27;name&#x27;); // =&gt; &#123; foo:&#x27;bar&#x27; &#125;Cookies.getJSON();  // =&gt; &#123; name:&#123; foo: &#x27;bar&#x27; &#125; &#125;\n\nset方法支持的属性\nexpires定义有效期。如果传入Number,那么单位为天，也可以传入一个Date对象，表示有效期至Date指定时间。如果省略，cookie将成为会话cookie。默认 当用户关闭浏览器时Cookie被删除。\npathstring, 表示cookie对哪个地址可见，默认为 /\ndomainstring, 表示此cookie对哪个域名可见。改cookie也将对所有子域可见。 默认Cookie仅对创建该cookie的页面的域或其子域可见。\nsecuretrue | false, 表示cookie传输是否仅支持https，默认 无安全协议要求\n\n","categories":["浏览器存储"]},{"title":"sync修饰符","url":"/2021/08/27/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"\n\nVue中的.sync修饰符\n\n   在Vue中，子父组件组常用的通信方式就是通过 props 进行数据传递，props 值只能在父组件更新并传递给子组件，在子组件内部是不允许改变传递进来的 props 值，这样做是为了保证数据的单向流通。但有时候，需要在子组件内部改变 props 属性值并更新到组件中，这时就需要用到.sync修饰符\n\nsync修饰符做了两件事\n\n声明要传递的数据\n声明自定义事件:title.sync就是:title=&quot;title&quot; @update:title=&quot;title=$event&quot;的缩写\n\n父组件：\n&lt;child :title.sync=&quot;title&quot;&gt;&lt;/child&gt;等同于&lt;child :title=&quot;title&quot; @update:title=&quot;title = $event&quot;&gt;&lt;/child&gt;\n子组件：\n&lt;div class=&quot;doc&quot;&gt;  &lt;h1 class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;  &lt;button @click=&quot;changeTitle&quot;&gt;修改标题&lt;/button&gt;&lt;/div&gt;/**************************************************/props: &#123;  title: &#123;    type: String,  &#125;,&#125;,methods: &#123;  changeTitle() &#123;    this.$emit(&quot;update:title&quot;, &quot;新标题&quot;);  &#125;,&#125;,\n\n若要传递的值为一个对象下的多个值，可以通过v-bind.sync=&quot;doc&quot;将对象中每个值分别传给子组件\n父组件：\n&lt;child v-bind.sync=&quot;doc&quot;&gt;&lt;/child&gt;&lt;script&gt;\texport default &#123;  data() &#123;    return &#123;      doc: &#123;        title: &quot;初始标题&quot;,        content: &quot;初始内容&quot;,      &#125;,    &#125;;  &#125;,&lt;/script&gt;\n子组件：\n&lt;div class=&quot;doc&quot;&gt;  &lt;h1 class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;  &lt;div class=&quot;content&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;changeContent&quot;&gt;修改标题&lt;/button&gt;&lt;/div&gt;/**************************************************/props: &#123;  title: &#123;    type: String,  &#125;,  content:&#123;    type: String  &#125;&#125;,methods: &#123;  changeContent() &#123;    this.$emit(&quot;update:content&quot;, &quot;新内容&quot;);  &#125;,&#125;,","categories":["Vue"],"tags":["修饰符"]},{"title":"Vue中watch用法详解","url":"/2021/06/22/watch/","content":"基本用法  当data中变量的值变化时，watch监听到并且执行\nexport default &#123;  data()&#123;    return &#123;      value:&#x27;&#x27;    &#125;  &#125;,  watch:&#123;    value(newVal, oldVal)&#123;      /* 要执行操作 */     &#125;  &#125;&#125;\n\n\nhandler方法和immediate属性  上面的例子只有value的值变化时，watch才会执行。如果想从开始的时候就对value进行监听，就需要用到 handler 和 immediate属性\nwatch:&#123;  value:&#123;    handler(newVal, oldVla) &#123;      /* 要执行操作 */     &#125;,    // 当immediate 值为true时, 会立即执行handler方法    // 如果值为false，效果同上面例子    immediate:true  &#125;&#125;\n\ndeep属性（深度监听）\n当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变。需要添加deep属性对 对象进行深度监听\n\nexport default &#123;  data()&#123;    return &#123;      obj:&#123;        a: 1,        b: 2,        c:&#123;          d:3          f:4        &#125;      &#125;    &#125;  &#125;,  watch:&#123;    obj:&#123;      handler(newVal, oldVal)&#123;&#125;,      immediate:true,      deep:true    &#125;  &#125;&#125;\n\n\n此时会给整个对象的属性都加上监听，当对象属性较多时，每个值变化都会触发handler函数。如果只需要监听一个属性，可以使用字符串形式监听对象内的单个属性\n\nwatch:&#123;  &#x27;c.d&#x27;:&#123;    handler(newVla, oldVal)&#123;&#125;,    immediate:true,    deep:true  &#125;&#125;\n\n数组（一维、多维）的变化不需要通过深度监听，对象数组中对象的属性变化需要deep的深度监听\n\n","categories":["Vue"],"tags":["Vue"]},{"title":"webpack","url":"/2021/06/07/webpack/","content":"webpack.config.js配置项模板\nconst path = require(&#x27;path&#x27;),\tHtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123;  mode: &quot;development&quot;,  // development 开发环境    production  生产环境  // 入口文件  多页面要写成对象格式  entry:&#123;    // 名: 路径    index:path.resolve(__dirname, &#x27;./src/js/index.js&#x27;);  &#125;,  // 打包  outpyt:&#123;    // 打包到哪个文件夹下    path: path.resolve(__dirname, &#x27;/dist&#x27;),    filename: &#x27;js/[name].js&#x27;   //  name是一个变量，自动去寻找entry 下的文件名  &#125;,  // 配置规则  module:&#123;    rules:[      // 匹配相同文件后缀结尾的文件，规定这类文件要使用什么loader      &#123;        test: /\\.js$/,        loader: &#x27;babel-loader&#x27;,        exclude: path.resolve(__dirname, &#x27;node_modules&#x27;)  // 编译转换时 排除node_modules 内的js文件       &#125;,      &#123;        test: /\\.css$/,        // 需处理多个loader时，写成数组形式        // 处理 use 数组时， 案由下到上的顺序，先经过 css-loader  再处理 style-loader        use:[          &#x27;style-loader&#x27;,          &#x27;css-loader&#x27;        ]      &#125;,      &#123;        test: /\\.scss$/,        use:[          &#x27;style-loader&#x27;,          &#x27;css-loader&#x27;,          &#x27;scss-loader&#x27;        ]      &#125;,      &#123;        test: /\\.tpl$/,        loader: &#x27;ejs-loader&#x27;      &#125;    ]  &#125;,  // 放入实例化对象， 例： 需要处理html时，require(&#x27;html-webpack-plugin&#x27;) 需要引入对应插件（一个构造函数）  // 所有的loader 都不会导入到配置文件中， 以plugin结尾的一般都需要导入  plugins:[    new HtmlWebpackPlugin(&#123;      minify:&#123;        // 移除所有注释        removeComments: true,        // 清除所有的空格和换行        collapseWhitespace: true      &#125;,      // 打包后的文件名称      filename: &#x27;index.html&#x27;,      // 需要打包的文件      template: path.resolve(__dirname, &#x27;/src/index.html&#x27;),      // 入口文件 取决于 entry 里的键名，如果有多个，使用数组的形式      chunks:[&#x27;index&#x27;],      // 排除node_modules      excludeChunks: [&#x27;node_modules&#x27;]    &#125;)  ],  devServer:&#123;    // 当启动devServer时 自动打开浏览器    open: true,    // 主机    host: &#x27;localhost&#x27;,    // 端口号    port: 3300  &#125;&#125;\n配置运行 webpack 的命令\npackage.json\n\n&quot;scripts&quot;: &#123;  &quot;...&quot;: &quot;...&quot;,  &quot;dev&quot;: &quot;webpack-dev-server --config webpack.config.js --reason  --color  --progress&quot;,  // 打包时的命令  &quot;webpack&quot;: &quot;webpack --config webpack.config.js&quot;&#125;\ndev配置可选项webpack-dev-server          启动服务--content-base dist/        dev-server 运行的目录--hot                       热启动--config webpack.config.js  webpack配置项--progress                  打包的进度--display-modules           打包时的模块--colors                    打包时输出彩色文字--display-reasons           打包时的提示信息\n\n\n依赖项\n安装在开发环境下的–save-dev  /     -D安装在生产环境下    例：ejs–save     /    -S\n\nwebpack 必备工具:\nwebpackwebpack-cliwebpack-dev-server\n\n\n\n\n\n\n处理JS  -&gt;  ES6  ES7  ES8 装饰器  babel 编译\nES6：babel-loader@7babel-corebabel-preset-envES7:babel-plugin-transform-runtimeES8:babel-plugin-transform-decoratorsbabel-plugin-transform-decorators-legacy\n\n\n\n\n\n\n样式处理  sass -&gt; css -&gt; style\nsass-loadernode-sasscss-loaderstyle-loader\n\n\n\n\n\nForth Step:\n\n\n模板处理  ejs  ||  tpl\nejs-loader\n\n\n\n\n\n\n处理HTML\nhtml-webpack-plugin\n\n\n\n\n","categories":["webpack"],"tags":["webpack"]},{"title":"执行期上下文","url":"/2021/07/05/%E6%89%A7%E8%A1%8C%E6%9C%9F%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"执行期上下文详解(点击跳转)\n"},{"title":"接口的错误拦截","url":"/2021/06/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA/","content":"对axios进行基础配置//  main.jsimport axios from &#x27;axios&#x27;const instance = axios.create(&#123;  baseURL = &#x27;/api&#x27;,  // 根据前端的跨域方式做调整  timeout = 8000   // 设置超时时间&#125;)\n\nrequest拦截器（请求发送后端之前）instance.interceptors.request.use(  config =&gt; &#123;    console.log(config);  // config将发送到后端    config.headers.token = &#x27;此处可设置token的内容&#x27;;    return config;  &#125;,  error =&gt; &#123;  //当发生错误时，执行该部分代码    console.log(error);  //打印错误信息    return Promise.reject(error)  &#125;)\n\nresponse拦截器（数据返回后）instance.interceptors.response.use(  response =&gt; &#123;    let res = response.data;    if(&#x27;状态码正确&#x27;)&#123;      return res;    &#125;else&#123;      alert(&#x27;弹出此异常&#x27;)      return Promise.reject(&#x27;error&#x27;)    &#125;  &#125;,  error =&gt; &#123;    console.log(error),    return Promise.reject(error);  &#125;)\n\n\n\n\n\n\n","categories":["axios"]},{"title":"Promise","url":"/2021/06/07/Promise/","content":"Promise详解\nPromise 基本用法\n\npromise有三个状态:&nbsp;&nbsp;&nbsp;&nbsp;pending[待定] 初始状态 &nbsp;&nbsp;|&nbsp;&nbsp; fulfilled[实现] 成功 &nbsp;&nbsp;|&nbsp;&nbsp; rejected[被否决] 失败当promise状态发生改变时，就会触发then()里的响应函数处理后续步骤；promise 状态一经改变，状态固化，不会再改变Promise 有两种状态改变的方式，既可以从pending转变为fulfilled,也可以从pending转变为rejected.一旦状态改变,就固化了，会一直保持这个状态，不会再发生变化。当状态发生变化时，promoise.then绑定的函数会被立即调用。new Promise() 是同步执行,一旦新建会「立即执行」，无法取消。\n\n\n使用new构建一个Promise对象.Promise接受一个函数参数,该函数的两个参数分别是resolve和reject.这两个函数就是回调函数.resolve函数的作用: 在异步操作成功时调用,并将异步操作的结果作为参数传递出去;reject函数: 在异步操作失败时调用,并将异步操作报出的错误作为参数传递出去.\nPromise实例生成后,可以用then方法指定resolved状态和rejected状态的回调函数.\n// 构建Promisevar promsie = new Promise( function(resolve, reject)&#123;  if(/*异步任务执行成功*/)&#123;    resovle()  &#125;else&#123;    /*异步任务执行失败*/     reject()  &#125;&#125;)promise.then( function(data)&#123;  // resolve调用的 成功的回调函数&#125;, function(error)&#123;  // reject调用的 失败的回调函数&#125;)\nthen方法会返回一个Promise对象,它有两个参数,分别为Promise从pending变为fulfilled和rejected时的回调函数(第二个参数非必选). 这两个函数都接受Promise对象传出的值作为参数.then就是定义resolve和reject函数的,其resolve参数相当于:\nfunction resolveFun(data)&#123;  // data为promise传出的值&#125;\n新建Promise中的’resolve(data)’,相当于执行resolveFun函数.Promise新建后就会立即执行.then方法中指定的回电函数,将当前脚本所有同步任务执行完成后才会执行.\nvar promise = new Promise( function(resolve, reject)&#123;  console.log(1);  resolve();  console.log(2);&#125;)promise.then( function()&#123;  console.log(3);&#125;)console.log(4)// 输出: 1, 2, 4, 3\n由于resolve指定的是异步操作成功后的回调函数，他需要等所有同步代码执行完成后才会执行，因此最后打印 3。\n基本API.then()\n语法: Promise.prototype.then(onFulfilled, onRejected)对promise添加onFulfilled和onRejected回调, 并返回的是一个新的Promise实例(不是.then前的那个Promise实例),且将返回值作为参数传入这个新的Promise对象的resolver函数因此，我们可以使用链式写法。由于前一个回调函数返回的还是一个Promise对象（即有异步操作），后一个回调函数会等待该Promise对象的状态发生变化，才会被调用\n\n/* ajax异步回调 */function request(url, param, successFun, errorFun)&#123;  $.ajax(&#123;    type:&#x27;GET&#x27;,    url:url,    param:param,    async:true,    success: successFun,    error: errorFun  &#125;)&#125;/* 构建promise实例 */ function test(url, param)&#123;  return new Promise( function(resolve, reject)&#123;    request(url, param, resolve, reject)  &#125;)&#125;/* Promise的链式调用 */ test(&#x27;test1.html&#x27;, &#x27;&#x27;).then( function(data1)&#123;  console.log(&#x27;第一次请求成功&#x27;,data1);  return test(&#x27;test2.html&#x27;,data1)&#125;).then( function(data2)&#123;  console.log(&#x27;第二次请求成功&#x27;， data2)  return test(&#x27;test3.html&#x27;, data2)&#125;).then( function(data3)&#123;  console.log(&#x27;第三次请求成功&#x27;， data3)&#125;).catch( function(error)&#123;  // catch 捕捉前面的错误  console.log(&#x27;请求失败&#x27;, error)&#125;)\n.catch()\n语法: Promise.prototype.catch(onRejected)该方法是.then(null, onRejected)的另一种写法,用于指定发生错误时的回调函数.\n\npromise.then( function(data)&#123;&#125;)    .cathc( function(error)&#123;&#125;)/****** 等同于 ******/ promise.then( function(data)&#123;&#125;, function(error)&#123;&#125;)\nvar promise = new Promise( function(resolve, reject)&#123;  throw new Error(&#x27;error&#x27;);&#125;)/****** 等同于 ******/ var promise = new Promise( function(resolve, reject)&#123;  reject(new Error(&#x27;error&#x27;));&#125;)/* 用catch捕捉错误 */ promise.catch( function(error)&#123;  console.log(error)&#125;)// 输出： Uncaught (in promise) Error: error\nreject等同于抛出错误。promise对象的错误，会一直向后传递，直到被捕获。 即错误总会被下一个catch所捕获,then方法指定的回调函数若抛出错误,也会被下一个catch捕获. catch中也能抛错,则需要后面的catch捕获.\ntest(&#x27;test1.html&#x27;).then( function(data1)&#123;  // 要执行的操作&#125;).then(function(data2)&#123;  // 要执行的操作&#125;).catch( function(err)&#123;  // 处理前面三个Promise 产生的错误&#125;)\n上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦fulfilled了，再抛错，也不会变为rejected，就不会被catch了。\nvar promise = new Promise( function(resolve, reject)&#123;  resolve();  throw &#x27;error&#x27;&#125;)promise.catch( function(err)&#123;  console.log(err)&#125;)\n如果没有使用catch方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点\n.all()\n语法: Promise.all(iterable)该方法用于将多个Promise实例，包装成一个新的Promise实例。\n\nvar p = Promise.all([p1, p2, p3]);\n\nPromise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。\n\n当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数\nvar p1 = new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 3000, &quot;first&quot;);&#125;);var p2 = new Promise(function (resolve, reject) &#123;    resolve(&#x27;second&#x27;);&#125;);var p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(resolve, 1000, &quot;third&quot;);&#125;); Promise.all([p1, p2, p3]).then(function(values) &#123;   console.log(values); &#125;);//约 3s 后  [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;] \n当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数，如例3.9。\nvar p1 = new Promise((resolve, reject) =&gt; &#123;   setTimeout(resolve, 1000, &quot;one&quot;); &#125;); var p2 = new Promise((resolve, reject) =&gt; &#123;   setTimeout(reject, 2000, &quot;two&quot;); &#125;);var p3 = new Promise((resolve, reject) =&gt; &#123;  reject(&quot;three&quot;);&#125;);Promise.all([p1, p2, p3]).then(function (value) &#123;    console.log(&#x27;resolve&#x27;, value);&#125;, function (error) &#123;    console.log(&#x27;reject&#x27;, error);    // =&gt; reject three&#125;);// 输出 reject three\n这多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128\nfunction timerPromisefy(delay) &#123;    return new Promise(function (resolve) &#123;        setTimeout(function () &#123;            resolve(delay);        &#125;, delay);    &#125;);&#125;var startDate = Date.now();Promise.all([    timerPromisefy(1),    timerPromisefy(32),    timerPromisefy(64),    timerPromisefy(128)]).then(function (values) &#123;    console.log(Date.now() - startDate + &#x27;ms&#x27;);    console.log(values);&#125;);// 输出：133ms       //不一定，但大于128ms//      [1,32,64,128]\n\n.race()\n语法： Promise.race(iterable)该方法同样是将多个Promise实例，包装成一个新的Promise实例\n\np = Promise.race([p1,p2,p3])\nPromise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。\nvar p1 = new Promise(function(resolve, reject) &#123;     setTimeout(reject, 500, &quot;one&quot;); &#125;);var p2 = new Promise(function(resolve, reject) &#123;     setTimeout(resolve, 100, &quot;two&quot;); &#125;);Promise.race([p1, p2]).then(function(value) &#123;    console.log(&#x27;resolve&#x27;, value); &#125;, function(error) &#123;    // 不执行    console.log(&#x27;reject&#x27;, error); &#125;);// 输出：resolve twovar p3 = new Promise(function(resolve, reject) &#123;     setTimeout(resolve, 500, &quot;three&quot;);&#125;);var p4 = new Promise(function(resolve, reject) &#123;     setTimeout(reject, 100, &quot;four&quot;); &#125;);Promise.race([p3, p4]).then(function(value) &#123;    // 不执行    console.log(&#x27;resolve&#x27;, value);              &#125;, function(error) &#123;    console.log(&#x27;reject&#x27;, error); &#125;);// 输出：reject four\n在第一个promise对象变为resolve后，并不会取消其他promise对象的执行：\nvar fastPromise = new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#x27;fastPromise&#x27;);        resolve(&#x27;resolve fastPromise&#x27;);    &#125;, 100);&#125;);var slowPromise = new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#x27;slowPromise&#x27;);        resolve(&#x27;resolve slowPromise&#x27;);    &#125;, 1000);&#125;);// 第一个promise变为resolve后程序停止Promise.race([fastPromise, slowPromise]).then(function (value) &#123;    console.log(value);    // =&gt; resolve fastPromise&#125;);/** * fastPromise * resolve fastPromise * slowPromise     //仍会执行*/\n.resolve()\n语法：Promise.resolve(value);Promise.resolve(promise);Promise.resolve(thenable);可以看成 new Promise的快捷方式\n\nPromise.resolve(&#x27;Success&#x27;);/*******等同于*******/new Promise(function (resolve) &#123;  resolve(&#x27;Success&#x27;);&#125;);\n这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数。由于Promise.resolve()也是返回Promise对象，因此可以用.then()处理其返回值。\nPromise.resolve(&#x27;success&#x27;).then(function (value) &#123;  console.log(value);&#125;);// 输出： Success\n//Resolving an arrayPromise.resolve([1,2,3]).then(function(value) &#123;  console.log(value[0]);    // =&gt; 1&#125;);//Resolving a Promisevar p1 = Promise.resolve(&#x27;this is p1&#x27;);var p2 = Promise.resolve(p1);p2.then(function (value) &#123;  console.log(value);     // =&gt; this is p1&#125;);\nPromise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。\nvar p1 = Promise.resolve(&#123;   then: function (resolve, reject) &#123;     resolve(&quot;this is an thenable object!&quot;);  &#125;&#125;);console.log(p1 instanceof Promise);     // =&gt; truep1.then(function(value) &#123;  console.log(value);     // =&gt; this is an thenable object!  &#125;, function(e) &#123;  //not called&#125;);\n再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成resolved或rejected，状态不会再改变，这和新建promise是一样的。\nvar p1 = &#123;   then: function(resolve) &#123;    throw new Error(&quot;error&quot;);    resolve(&quot;Resolved&quot;);  &#125;&#125;;var p2 = Promise.resolve(p1);p2.then(function(value) &#123;  //not called&#125;, function(error) &#123;  console.log(error);       // =&gt; Error: error&#125;);//在回调函数后抛异常var p3 = &#123;   then: function(resolve) &#123;    resolve(&quot;Resolved&quot;);    throw new Error(&quot;error&quot;);  &#125;&#125;;var p4 = Promise.resolve(p3);p4.then(function(value) &#123;  console.log(value);     // =&gt; Resolved&#125;, function(error) &#123;  //not called&#125;);\n.reject()\n语法： Promise.reject(reason)这个方法和上述的Promise.resolve()类似，它也是new Promise()的快捷方式。\n\nPromise.reject(new Error(&#x27;error&#x27;));/*******等同于*******/new Promise(function (resolve, reject) &#123;  reject(new Error(&#x27;error&#x27;));&#125;);\n这段代码会让这个Promise对象立即进入rejected状态，并将错误对象传递给then指定的onRejected回调函数。\n常见问题reject 和 catch 的区别\n使用new Promise(fn)或者它的快捷方式Promise.resolve()、Promise.reject()，返回一个promise对象\n在fn中指定异步的处理 处理结果正常，调用resolve 处理结果错误，调用reject一般情况，还是建议使用第二种，因为能捕获之前的所有异常。第二种的.catch()也可以使用.then()表示，它们本质上是没有区别的，.catch === .then(null, onRejected)\n\n如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误function taskA() &#123;  console.log(x);  console.log(&quot;Task A&quot;);&#125;function taskB() &#123;  console.log(&quot;Task B&quot;);&#125;function onRejected(error) &#123;  console.log(&quot;Catch Error: A or B&quot;, error);&#125;function finalTask() &#123;  console.log(&quot;Final Task&quot;);&#125;var promise = Promise.resolve();promise  .then(taskA)  .then(taskB)  .catch(onRejected)  .then(finalTask);    // 输出： Catch Error: A or B,ReferenceError: x is not defined// 输出： Final Task\n上面例子的输出结果及流程图，可以看出，A抛错时，会按照 taskA → onRejected → finalTask这个流程来处理。A抛错后，若没有对它进行处理，状态就会维持rejected，taskB不会执行，直到catch了错误。\nfunction taskA() &#123;    console.log(x);    console.log(&quot;Task A&quot;);&#125;function taskB() &#123;    console.log(&quot;Task B&quot;);&#125;function onRejectedA(error) &#123;    console.log(&quot;Catch Error: A&quot;, error);&#125;function onRejectedB(error) &#123;    console.log(&quot;Catch Error: B&quot;, error);&#125;function finalTask() &#123;    console.log(&quot;Final Task&quot;);&#125;var promise = Promise.resolve();promise    .then(taskA)    .catch(onRejectedA)    .then(taskB)    .catch(onRejectedB)    .then(finalTask);    /** * 输出： * Catch Error: A ReferenceError: x is not defined * Task B * Final Task * */ \n将本例与上面的例子对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。\n每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据//方法1：对同一个promise对象同时调用 then 方法var p1 = new Promise(function (resolve) &#123;    resolve(100);&#125;);p1.then(function (value) &#123;    return value * 2;&#125;);p1.then(function (value) &#123;    return value * 2;&#125;);p1.then(function (value) &#123;    console.log(&quot;finally: &quot; + value);&#125;);// 输出： finally: 100//方法2：对 then 进行 promise chain 方式进行调用var p2 = new Promise(function (resolve) &#123;    resolve(100);&#125;);p2.then(function (value) &#123;    return value * 2;&#125;).then(function (value) &#123;    return value * 2;&#125;).then(function (value) &#123;    console.log(&quot;finally: &quot; + value);&#125;);// 输出： finally: 400\n第一种方法中，then的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。因此容易出现下面的错误写法：\nfunction badAsyncCall(data) &#123;    var promise = Promise.resolve(data);    promise.then(function(value) &#123;        //do something        return value + 1;    &#125;);    return promise;&#125;badAsyncCall(10).then(function(value) &#123;   console.log(value);          //想要得到11，实际输出10&#125;);//输出： 10\n正确的写法应该是：\nfunction goodAsyncCall(data) &#123;    var promise = Promise.resolve(data);    return promise.then(function(value) &#123;        //do something        return value + 1;    &#125;);&#125;goodAsyncCall(10).then(function(value) &#123;   console.log(value);&#125;);// 输出： 11\n在异步回调中抛错，不会被catch到// 异步函数中抛出的错误将像未捕获的错误一样var promise = new Promise(function(resolve, reject) &#123;  setTimeout(function() &#123;    throw &#x27;Uncaught Exception!&#x27;;  &#125;, 1000);&#125;);promise.catch(function(e) &#123;  console.log(e);       //不会调用&#125;);\npromise状态变为resove或reject，就凝固了，不会再改变console.log(1);new Promise(function (resolve, reject)&#123;    reject();    setTimeout(function ()&#123;        resolve();            //not called    &#125;, 0);&#125;).then(function()&#123;    console.log(2);&#125;, function()&#123;    console.log(3);&#125;);console.log(4);/** * 输出： * 1 * 4 * 3 * */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["javascript","Promise"],"tags":["promise"]},{"title":"vue3笔记","url":"/2022/02/10/vue3%E7%AC%94%E8%AE%B0/","content":"\n\n\n\ncomposition APIsetup在setup中应该避免使用this，因为this不指向组件实例\nsetup函数参数\n参数1: props\nprops就是父组件传递过来的属性，会被放到props对象中，如果需要在setup中使用，需要配合props配置项,通过props参数获取\n\n定义props的类型，还是在props配置项中定义\n且在template中依然是可以正常去使用props中的属性\n在setup函数中想要使用props，不可以通过 this 去获取，直接通过参数使用即可\n\n\n\n参数2: context\ncontext包含三个属性\n\nattrs：所有未在props中接收的属性\nslots：父组件传递过来的插槽\nemit：调用父组件方法时用到的emit\n\n\nexport default &#123;  props: &#123;    name: String  &#125;,  setup(props, &#123; attrs, slots, emit &#125;)&#123;    ...  &#125;&#125;\n\nsetup函数的返回值\nsetup的返回值可以在模板template中被使用,也就是说我们可以通过setup的返回值来替代data选项\n可以返回一个执行函数来代替在methods中定义的方法\n\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;name: &#123;&#123;name&#125;&#125;, age: &#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;    &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    setup()&#123;      let name = &#x27;TT&#x27;;      let age = 18;      const increment = () =&gt; &#123;        age++      &#125;      const decrement = () =&gt; &#123;        age--      &#125;      return &#123;        name,        age,        increment,        decrement      &#125;    &#125;  &#125;&lt;/script&gt;\n\nsetup不可以使用this\n表达的含义是this并没有指向当前组件实例\n并且在setup被调用之前，data、computed、methods等都没有被解析\n所以无法在setup中获取this\n\nsetup中使用ref\n只需要定义一个ref对象，绑定到元素或者组件的ref属性上即可\n\n&lt;template&gt;  &lt;div&gt;    &lt;h2 ref=&quot;titleRef&quot;&gt;我是标题&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123; ref &#125; from &#x27;vue&#x27;  export default &#123;    const titleRef = ref(null) // 先用null占位    return &#123;      titleRef    &#125;  &#125;&lt;/script&gt;\n\nReactive API\n如果想为在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数let state = reactive(&#123;  name: &#x27;TT&#x27;,  age: 18&#125;)\n原因\n这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集\n当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）\n事实上，我们编写的data选项，也是在内部交给了 reactive函数 将其编成响应式对象的\n\n\n限制\nreactive要求我们必须传入的是一个对象或数组类型，如果传入 基本数据类型(String, Number, Boolean)会报一个警告: value cannot be made reactive: Hello World\n\n\n\nRef API\nref 会返回一个可变的响应式对象， 该对象作为一个 响应式的引用 维护着它内部的值，这就是ref名称的来源\n它内部的值是在ref的value 属性中被维护的let message = ref(&quot;Hello World&quot;)console.log(message.value)  -&gt; &#x27;Hello World&#x27;\n注意事项：\n在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以我们并不需要在模板中通过ref.value的方式来使用\n但是在setup 函数内部，它依然是一个ref引用，所以对其进行操作时，我们依然需要使用ref.value的方式\n\n\n\nref自动解包\n\n模板中的解包是浅层解包，如果把ref对象放到一个普通对象内部，在模板中使用时将不会自动解包&lt;template&gt;  &lt;div&gt;    &lt;h2&gt; &#123;&#123; message &#125;&#125; &lt;/h2&gt;    &lt;h2&gt; &#123;&#123; info.message.value &#125;&#125; &lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123; ref &#125; from &#x27;vue&#x27;;  export default &#123;    setup()&#123;      let message = ref(&#x27;Hello World&#x27;);      let info = &#123;        message      &#125;      return &#123;        message,        info      &#125;    &#125;  &#125;&lt;/script&gt;\n如果我们将ref放到一个reactive的属性当中，那么在模板中使用时，它会自动解包&lt;template&gt;  &lt;div&gt;    &lt;h2&gt; &#123;&#123; message &#125;&#125; &lt;/h2&gt;    &lt;h2&gt; &#123;&#123; info.message &#125;&#125; &lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123; ref, reactive &#125; from &#x27;vue&#x27;;  export default &#123;    setup()&#123;      let message = ref(&#x27;Hello World&#x27;);      let info = reactive(&#123;        message      &#125;)      return &#123;        message,        info      &#125;    &#125;  &#125;&lt;/script&gt;\n\nreadonly\n何时使用？\n通过reactive或者ref可以获取到一个响应式对象，但如果希望传递给某些组件使用，并且不允许修改时\n\n\nreadonly会返回原生对象的只读代理（也就是它依然是一个Proxy，这是一个proxy的set方法被劫持，并且不 能对其进行修改）\n在开发中常见的readonly方法会传入三个类型的参数\n类型一：普通对象\n类型二：reactive返回的对象\n类型三：ref的对象\n\n\nreadonly的使用\nreadonly返回的对象都是不允许修改的\n经过readonly处理的原来的对象允许修改，当原对象改变时，readonly返回的对象也会被修改\n本质上就是readonly返回的对象的setter方法被劫持了而已\n\n\n\nReactive判断的API\nisProxy\n检查对象是否是由reactive 或readonly创建的proxy\n\n\nisReactive\n检查对象是否是由reactive创建的响应式代理\n如果该代理是readonly创建的，但包裹了由reactive 创建的另一个代理，它也会返回true\n\n\nisReadonly\n检查对象是否是由readonly创建的只读代理\n\n\ntoRaw\n返回reactive 或readonly代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）\n\n\nshallowReactive\n创建一个响应式代理，它跟踪其自身property 的响应性，但不执行嵌套对象的深层响应式转换(深层还是原生对象)\n\n\nshallowReadonly\n创建一个proxy，使其自身的property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）\n\n\n\ntoRefs\n如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改解构后的变量，还是修改reactive返回的state对象， 数据都不再是响应式的let info = reactive(&#123;  name: &#x27;TT&#x27;,  age: 18&#125;)let &#123; name, age &#125; = info\n解决办法\nVue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref\n那么我们再次进行解构出来的name 和age 本身都是ref的// 当我们这样写的时候，会返回两个ref对象，他们都是响应式的let &#123; name, age &#125; = toRefs(info)\n\n\n这种做法相当于已经在info.name和ref.value之间建立了链接，任何一个修改都会引起另外一个变化\n\ntoRef\n如果只希望转换一个reactive对象中的属性为ref, 那么可以使用toRef方法let name = toRef(info, &#x27;name&#x27;);const changeName = () =&gt; info.name = &#x27;zs&#x27;\n\nref的其他API\nunref\n如果我们想要获取一个ref引用中的value，可以通过unref方法\n如果参数是一个ref，则返回内部值，否则返回参数本身\n这是val= isRef(val) ? val.value: val的语法糖函数\n\n\nisRef\n判断值是否是一个ref对象\n\n\nshallowRef\n创建一个浅层的ref对象\n\n\ntriggerRef\n手动触发和shallowRef相关联的副作用let info = shallowRef(&#123; name: &#x27;tt&#x27; &#125;)// 下面的修改不是响应式的const changeInfo = () =&gt; &#123;  info.value.name = &#x27;zs&#x27;  // 手动触发  triggerRef(info)&#125;\n\n\n\ncustomRef\n创建一个 自定义的ref，并对其依赖项跟踪和更新触发进行显式控制\n它需要一个工厂函数，该函数接收track 和trigger 函数作为参数\n并且应该返回一个带有get 和set 的对象\n\n\n对双向绑定属性进行debounce(节流)的案例:import &#123; customRef &#125; from &#x27;vue&#x27;;export function useDebouncedRef(value, delay = 200) &#123;  let timeout;  return customRef( (track, trigger) =&gt; &#123;    return &#123;      get()&#123;        track();        return value      &#125;,      set(newValue)&#123;        clearTimeout(timeout);        timeout = setTimeout( () =&gt; &#123;          value = newValue;          trigger()        &#125;, delay)      &#125;    &#125;  &#125;)&#125;\n使用方式&lt;template&gt;  &lt;div&gt;    &lt;input v-model=&quot;msg&quot; /&gt;    &lt;h2&gt; &#123;&#123;msg&#125;&#125; &lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#123; useDebouncedRef &#125; from &#x27;@/hooks/useDebounceRef&#x27;;  export default &#123;    setup()&#123;      let msg = useDebouncedRef(&#x27;Hello World&#x27;)      return &#123;        msg      &#125;    &#125;  &#125;&lt;/script&gt;\n\ncomputed\n当我们的某些属性是依赖其他状态时，可以使用计算属性来处理\n在前面的Options API中，我们是使用computed选项来完成的\n在Composition API中，我们可以在setup 函数中使用computed 方法来编写一个计算属性\n\n\n用法\n方式一：接收一个getter函数，并为getter函数返回的值，返回一个不变的ref 对象import &#123; computed &#125; from &#x27;vue&#x27;const fullName = computed( ()=&gt;&#123;  return firstName.value + &#x27; &#x27; + lastName.value&#125;)\n方式二：接收一个具有get和set的对象，返回一个可变的（可读写）的ref对象const fullName = computed(&#123;  get: () =&gt; &#123;    return firstName.value + &#x27; &#x27; + lastName.value  &#125;,  set: newValue =&gt; &#123;    const names = newValue.split(&quot; &quot;);    firstName.value = names[0];    lastName.value = names[1]  &#125;&#125;)\n\n\n\n侦听数据的变化\n在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些操作\n在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听\nwatchEffect用于自动收集响应式数据的依赖\nwatch需要手动指定侦听的数据源\n\n\n\nwatchEffectwatchEffect用法\n当侦听到某些响应式数据变化时，我们希望执行某些操作，这个时候可以使用watchEffect\n看一个案例\n首先，watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖\n其次，只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行let name = ref(&#x27;tt&#x27;);let age = ref(18);watchEffect( ()=&gt;&#123;  console.log(&#x27;watchEffect执行&#x27;, name.value, age.value)&#125;)\n\n\n\nwatchEffect的停止侦听\n如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可\n比如在上面的案例中，我们age达到20的时候就停止侦听const stopWatch = watchEffect( ()=&gt;&#123;  console.log(&#x27;watchEffect执行&#x27;, name.value, age.value)&#125;)const changeAge = () =&gt; &#123;  age.value++  if(age.value &gt; 20)&#123;    stopWacth()  &#125;&#125;\n\nwatchEffect清除副作用\n什么是清除副作用呢？\n比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器，或者侦听器侦听函数被再次执行了\n那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用\n\n\n在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate\n当副作用即将重新执行或者侦听器被停止时会执行该函数传入的回调函数\n我们可以在传入的回调函数中，执行一些清除工作const stopWatch = watchEffect( (onInValidate) =&gt; &#123;  console.log(&#x27;watchEffect执行&#x27;, name.value, age.value)  const timer = setTimeout( ()=&gt;&#123;    console.log(&#x27;2s后执行的操作&#x27;)  &#125;, 2000);  onInvalidate( ()=&gt;&#123;    clearTimeout(timer)  &#125;)&#125;)\n\n\n\nwatchEffect的执行时机\n默认情况下，组件的更新会在副作用函数执行之前\n能不能在副作用函数中获取到元素呢？export default &#123;  setup()&#123;    const titleRef = ref(null);    const count = 0;    watchEffect( ()=&gt;&#123;      console.log(titleRef.value)    &#125;)    return &#123;      titleRef,      count    &#125;  &#125;&#125;/** * log: * &gt; null * &gt; &lt;h2&gt;&lt;/h2&gt;*/\n\n\n我们会发现打印结果打印了两次\n这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null\n而当DOM挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素\n\n\n\n调整watchEffect的执行时机\n如果我们希望第一次执行时就能打印出对应的元素\n这个时候我们需要改变副作用函数的执行时机\n它的默认值是pre，它会在元素挂载或者更新之前执行\n所以我们会先打印出来一个空的，当依赖的title发生改变时，就会再次执行一次，打印出元素\n\n\n设置副作用函数的执行时机\nwatchEffect的第二个参数&#123; flush: &#39;&#39; &#125;\nflush可选值：pre、post，sync\npre：默认。挂载前、更新前\npost：将推迟副作用函数的初始运行，直到组件的首次渲染完成才会执行\nsync：将强制效果始终同步触发。然而，这是低效的，应该很少需要let h2ElContent = null;watchEffect( ()=&gt;&#123;  h2ElContent = titleRef.value &amp;&amp; titleRef.value.textContent  console.log(h2ElContent, count.value)&#125;, &#123;  flush: &#x27;post&#x27;&#125;)\n\n\n\nwatchwatch的使用\nwatch的API完全等同于组件watch选项的Property：\nwatch需要侦听特定的数据源，并在回调函数中执行副作用\n默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调\n\n\n与watchEffect的比较，watch允许我们\n懒执行副作用(第一次不会直接执行)\n更具体的说明当哪些状态发生变化时，触发侦听器的执行\n访问侦听状态变化前后的值\n\n\n\n侦听单个数据源\nwatch侦听的数据源有两种类型：\n\n一个getter函数： 但是该getter函数必须引用可响应式的对象（ref或reactive）const info = reactive(&#123;name: &#x27;TT&#x27;, age: 18&#125;)watch( () =&gt; info.name, (newVal, oldVal)=&gt;&#123;    console.log(&#x27;new:&#x27;, newVal, &#x27;old:&#x27;, oldVal);&#125;)\n侦听响应式对象，reactive或者ref(比较常用的是ref)// 情况一： reactive对象获取到的newValue和oldValue本身都是 reactive对象watch(info, (newVal, oldVal)=&gt;&#123;    console.log(&#x27;new:&#x27;, newVal, &#x27;old:&#x27;, oldVal);&#125;)\n\n\n// 如果希望newValue和oldValue是一个普通的对象,可以使用扩展运算符watch(()=&gt; &#123;    return &#123;...info&#125;&#125;, (newVal, oldVal)=&gt;&#123;    console.log(&#x27;new:&#x27;, newVal, &#x27;old:&#x27;, oldVal);&#125;)\n\n侦听多个数据源const name = ref(&#x27;TT&#x27;)const age = ref(18)const changeName = () =&gt; &#123;    name.value = &#x27;zs&#x27;&#125;  //     数组写法        使用多个数组接收新旧值watch([info, name], ([newInfo, newName], [oldInfo, oldName])=&gt;&#123;    console.log(&#x27;new:&#x27;, newInfo, &#x27;old:&#x27;, oldInfo);    console.log(&#x27;new:&#x27;, newName, &#x27;old:&#x27;, oldName);&#125;)\n\n侦听响应式对象\n监听到的对象为reactive对象  watch(info, (newInfo, oldInfo)=&gt;&#123;    console.log(&#x27;new:&#x27;, newInfo, &#x27;old:&#x27;, oldInfo);&#125;)如果希望监听到的对象或数组为普通对象，可以使用一个getter函数，并且对可响应对象进行解构  const arr = active([1,2,3,4])watch(()=&gt;([...arr]), (newArr, oldArr)=&gt;&#123;    console.log(&#x27;new:&#x27;, newArr, &#x27;old:&#x27;, oldArr);&#125;\n\nwatch的选项\n如果想进行深层侦听，需要在watch的第三个对象参数设置deep为true\n如果想立即执行一次watch，也可以传入immediateconst info = reactive(&#123;    name: &#x27;TT&#x27;,     age: 18,    friend: &#123;        name: &#x27;ls&#x27;    &#125;&#125;)//        需要用小括号包裹watch( ()=&gt;(&#123;...info&#125;) , (newInfo, oldInfo)=&gt;&#123;    console.log(&#x27;new:&#x27;, newInfo, &#x27;old:&#x27;, oldInfo);&#125;,&#123;    deep: true,    immediate: true&#125;)const changeData = () =&gt;&#123;    info.name = &#x27;zs&#x27;&#125;\n\n生命周期钩子\n使用直接导入的 onXXX 函数注册生命周期钩子，这些函数接受一个回调函数，当钩子被组件调用时将会被执行\n\n  import &#123; onMounted, onUpdated, onUnmounted &#125; from &#x27;vue&#x27;setup()&#123;    onMounted(()=&gt;&#123;        console.log(&quot;App onMounted&quot;)    &#125;)    onUpdated( ()=&gt;&#123;        console.log(&quot;App onUpdated&quot;)    &#125;)    onUnmounted( ()=&gt;&#123;        console.log(&quot;App onUnmounted&quot;)    &#125;)&#125;\n\n\n\n\n选项式API\nHook inside setup\n\n\n\nbeforeCreate\nNot needed*\n\n\ncreated\nNot needed*\n\n\nbeforeMount\nonBeforeMount\n\n\nmounted\nonMounted\n\n\nbeforeUpdate\nonBeforeUpdate\n\n\nupdated\nonUpdated\n\n\nbeforeDestroy\nonBeforeUnmount\n\n\ndestroyed\nonUnmounted\n\n\nactivated\nonActivated\n\n\ndeactivated\nonDeactivated\n\n\n\nTIP因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。\n\ncreated()&#123;    axios.get(&#x27;/api/***&#x27;).then()&#125;// 改为直接写在setup 函数内setup()&#123;    axios.get(&#x27;/api/***&#x27;).then()&#125;\n\nhook的使用实现一个监听界面滚动位置的Hook\nimport &#123; ref &#125; from &#x27;vue&#x27;;export default function() &#123;  let scrollX = ref(0);  let scrollY = ref(0);  document.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123;    scrollX.value = window.scrollX    scrollY.value = window.scrollY  &#125;)  return &#123; scrollX, scrollY &#125;&#125;\n\n实现一个使用localStorage存储和获取数据的Hook\nimport &#123; ref, watch &#125; from &#x27;vue&#x27;export default function(key, value)&#123;  let data = ref(value);  // 如果传入了value， 就把key 和 value 存起来  // 否则就去localStorage里找key对应的值  if(value)&#123;    window.localStorage.setItem(key, JSON.stringify(value))  &#125; else &#123;    data.value = JSON.parse(window.localStorage.getItem(key))  &#125;  // 如果data的值发生了改变，要把localStorage内对应的值也修改  watch( data, (newValue) =&gt; &#123;    window.localStorage.setItem(key, JSON.stringify(newValue))  &#125;)  return data&#125; \n\n用法\nimport &#123; useScrollPosition, useLocalstorage &#125; from &#x27;./hooks&#x27;export default &#123;  setup()&#123;    // scoll    let &#123;scrollX, scrollY&#125; = useScrollPosition()    // localstorage    let data = useLocalstorage(&#x27;info&#x27;, &#123; name: &#x27;TT&#x27;, age: 18 &#125;)    const changeData = () =&gt; data.value = &#x27;hello world&#x27;    return &#123;      // ...useScrollPosition()      scrollX,      scrollY,      data,      changeData    &#125;  &#125;&#125;\n\n\n组件间通信父子组件通信\n父组件传递给子组件：通过props属性\n使用v-bind传递给子组件，子组件使用Props接收\n\n\n子组件传递给父组件通过$emit触发事件\n需要在子组件中写入一个新的配置项emits接收父组件传递的事件名称\n\n// 父组件&lt;template&gt;  &lt;div&gt;    &lt;child @increment=&#x27;increment&#x27; @decrement=&#x27;decrement&#x27;&gt;&lt;/child&gt;  &lt;/div&gt;&lt;/template&gt;...// 子组件&lt;script&gt;  export default &#123;    emits: [ &#x27;increment&#x27;, &#x27;decrement&#x27; ],    setup(props, &#123; attrs, slots, emit &#125;)&#123;      addOne()&#123;        emit.increment()      &#125;      subOne()&#123;        emit.decrement()      &#125;    &#125;  &#125;&lt;/script&gt;\n\n非父子组件的通信provide和inject\nProvide/Inject用于非父子组件之间共享数据\n比如有一些深度嵌套的组件，后代组件想要获取祖先组件的部分内容\n在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会常的麻烦\n\n\n这种情况下，可以使用Provide 和Inject\n无论层级结构有多深，祖先组件都可以作为其所有后代组件的依赖提供者\n父组件有一个 provide 函数来提供数据\n子组件有一个 inject 函数来接收这些数据\n\n\n\nProvide函数\n可以通过provide方法定义每个Property\nprovide接收两个参数\nkey： 提供的属性名称（后代组件接收时的名称）\nvalue：提供的属性值import &#123; provide &#125; from &#x27;vue&#x27;let count = 100;let info = &#123;    name: &#x27;TT&#x27;,    age: 18&#125;provide(&#x27;counter&#x27;, count)provide(&#x27;info&#x27;, info)\n\n\n\nInject函数\n在后代组件 中可以通过inject 来注入需要的属性和对应的值\ninject可以传入两个参数\nkey：要接收的属性的key\ndefaultValue：默认值（可不传）let name = inject(&#x27;name&#x27;)let info = inject(&#x27;info&#x27;)\n\n\n\nprovide/inject 的响应式\n为了增加 provide 值和 inject 值之间的响应性，可以在 provide 值时使用 ref 和 reactive\n未防止后代组件修改值，可在provide传递时使用readonlylet name = ref(&#x27;TT&#x27;);let info = reactive(&#123;    name: &#x27;TT&#x27;,    age: 18&#125;);provide(&#x27;name&#x27;, readonly(name))provide(&#x27;info&#x27;, readonly(info))\n后代组件需要修改inject接收到的值时，要遵守单向数据流原则，可以将修改的方法在祖先组件中定义，在后代组件中调用/***** 祖先组件 *******/  let name = ref(&#x27;TT&#x27;);  const changeName = () =&gt; &#123; name.value = &#x27;zs&#x27; &#125;  provide(&#x27;name&#x27;, readonly(name))  provide(&#x27;changeName&#x27;, changeName)  /***** 后代组件 *******/  let changeName = inject(&#x27;changeName&#x27;)  const emitChangeName = () =&gt; &#123;      changeName()  &#125;\n\n全局事件总线mitt库\nVue3从实例中移除了$on、$off 和$once 方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库\nVue3官方有推荐一些库，例如mitt或tiny-emitter\n\n\n封装一个通信工具库eventbus.js:import mitt from &#x27;mitt&#x27;;const emitter = mitt();export default emitter;\n使用方式\n\n监听\nimport emitter from &#x27;./eventBus&#x27;;export default &#123;  setup()&#123;    // 监听单个事件    emitter.on(&#x27;tt&#x27;, (info) =&gt; &#123;      console.log(&#x27;tt event:&#x27;， info)    &#125;)        // 监听所有事件    emitter.on(&#x27;*&#x27;, (type, e) =&gt; &#123;      console.log(&#x27;* event:&#x27;, type, e)    &#125;)  &#125;&#125;\n触发事件总线\nimport emitter from &#x27;./eventBus&#x27;export default &#123;  setup()&#123;    const triggerEvent = () =&gt; &#123;      emitter.emit(&#x27;tt&#x27;, &#123; name: &#x27;tt&#x27;, age: 18 &#125;)    &#125;  &#125;&#125;\n\n取消监听\n// 取消所有监听emitter.all.clear()// 如果只想取消某一个事件的监听，要把on监听的回调函数单独定义，例：watchFoo(data)&#123;&#125;emitter.on(&#x27;foo&#x27;, watchFoo)emitter.off(&#x27;foo&#x27;, watchFoo)\n","categories":["Vue"],"tags":["vue3"]},{"title":"Vue-cli笔记","url":"/2021/08/16/Vue-cli%E7%AC%94%E8%AE%B0/","content":"\n\n脚手架文件结构├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n\n关于不同版本的Vue\nvue.js与vue.runtime.xxx.js的区别：\nvue.js是完整版的Vue，包含：核心功能+模板编译器\nvue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。\n\n\n因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。\n\nvue.config.js 配置文件\n使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。\n使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh/config/\n\nref属性\n被用来给元素或子组件注册引用信息(id的替代者)\n应用在html标签上获取的是真实dom元素， 应用在组件标签上是组件实例对象\n使用方式\n打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt; 或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;\n获取：this.$refs.xxx\n\n\n\nprops配置项\n功能：让组件接收外部传过来的数据\n传递数据： &lt;demo :name=&quot;xxx&quot;&gt;\n接收数据：\n第一种方式（只接收）：props:[&#39;name&#39;]\n第二种方式（限制类型）： props:&#123;name:&#39;String&#39;&#125;\n第三种方式（限制类型、限制必要性、指定默认值）： props:&#123;  name:&#123;    type:String, //类型    required:true,\t// 必要性    default:&#x27;老王&#x27;\t// 默认值  &#125;&#125;\n\n\n可接受的类型- String- Number- Boolean- Array- Object- Date- Function- Symbol\n\n备注： props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若确实需要修改，可复制一份props的内容到data中，然后修改data中的数据\n\n\n\nmixin(混入)\n功能：可以把多个组件共用的配置提取成一个混入对象\n使用方式： 第一步定义混合： &#123;   data()&#123;&#125;,   methods:&#123;&#125;,   ... ... &#125;\n第二部使用混入：全局混入：Vue.mixin(xxx)局部混入：mixins:[&#39;xxx&#39;]\n\n插件\n功能：用于增强Vue\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n定义插件：export default &#123;  install(Vue, options)&#123;    // 1. 添加全局过滤器    Vue.filter(....)    // 2. 添加全局指令    Vue.directive(....)    // 3. 配置全局混入(合)    Vue.mixin(....)    // 4. 添加实例方法    Vue.prototype.$myMethod = function () &#123;...&#125;    Vue.prototype.$myProperty = xxxx  &#125;&#125;\n使用插件：Vue.use(xxx)\n\nscoped样式\n作用：让样式在局部生效，防止冲突\n写法：&lt;style scoped&gt;\n\n组件拆分案例\n组件化编码流程 (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突 (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用： 1). 一个组件在用，放在自身即可。\n 2). 多个组件在用：放在他们共同的父组件上（&lt;span style=&quot;color:red&quot;&gt;状态提升&lt;/span&gt;）\n\n (3).实现交互： 从绑定开始\nprops适用于： (1). 父组件 ==&gt; 子组件 通信 (2). 子组件 =&gt;&gt; 父组件 通信（需要父组件先给子组件一个函数，子组件调用时传参）\n使用v-model时要切记： v-model绑定的值不能是props传过来的值，因为props不可修改\nprops传过来的若是对象的值，修改对象中的属性是Vue不会报错，但不推荐这样做\n\nwebStorage\n存储内容大小一般支持5MB左右（不同浏览器之间可能会有区别）\n\n浏览器端通过 window.sessionStorage 和 window.localStorage属性实现本地存储机制\n\n相关API：\n\nxxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\nxxxxxStorage.getItem(&#39;person&#39;); ​该方法接受一个键名作为参数，返回键名对应的值。\n\nxxxxxStorage.removeItem(&#39;key&#39;); ​该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n xxxxxStorage.clear() ​该方法会清空存储中的所有数据。\n\n\n\n备注：\n\nSessionStorage存储的内容会随着浏览器的窗口关闭而消失\nLocalStorage存储的内容，需要手动清除才会消失\nxxxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null\nJSON.parse(null) 的结果依然是null\n\n\n\n组件的自定义事件\n一种组件间通信的方法，适用于：子组件 ===&gt; 父组件\n\n使用场景： A是父组件，B是子组件，B想给A传递数据，就要在A中给B绑定自定义事件（事件的回调在A中）。\n\n绑定自定义事件：\n\n第一种方法，在父组件中：&lt;Demo @children=&quot;parent&quot; /&gt;\n第二种方法，在父组件中：  &lt;Demo ref=&quot;demo&quot; /&gt;...mounted()&#123;  this.$refs.xxx.$on(&#x27;子组件事件名&#x27;,this.getData/*父组件自己的方法*/)&#125;\n若只想让自定义事件触发一次，可以使用once修饰符，或$once方法\n\n\n触发自定义事件：this.$emit(&#39;事件名&#39;,要传递的数据)\n\n解绑自定义事件：this.$off(&#39;事件名&#39;)\n\n组件上也可以绑定原生的dom事件，需要用native修饰符。\n\n注意：通过this.$refs.xxx.$on(&#39;子组件事件名&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！\n\n\n全局事件总线(GlobalEventBus)\n一种组件间通信的方式，适用于任意组件间通信\n\n安装全局事件总线：\n new Vue(&#123;  ....,  beforeCreate()&#123;    Vue.prototype.$bus = this //安装全局事件总线, $bus就是当前应用的vm  &#125;,  ....&#125;)\n使用事件总线：\n\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身\n提供数据： this.$bus.$emit(&#39;tt&#39;,数据)\n\n\n最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。\n   // A组件methods:&#123;  demo(data)&#123; ... &#125;&#125;... ...mounted()&#123;  this.$bus.$on(&#x27;tt&#x27;,this.demo)&#125;,beforeDestroy() &#123;  this.$bus.$off(&quot;tt&quot;);&#125;// B组件methods:&#123;  test()&#123;    this.$bus.$emit(&#x27;tt&#x27;,params)  &#125;&#125;\n\n消息订阅与发布（pubsub）\n一种组件间通信的方式，适用于任意组件间通信\n\n使用步骤:\n\n安装pubsub：npm i  pubsub-js\n引入：import pubsub from &#39;pubsub-js&#39;\n接收数据：A组件想接受的数据，则在A组件中订阅消息，订阅的回调留在A组件自身。\n提供数据： pubsub.publish(&#39;xxx&#39;, 数据)\n最好在beforeDestroy钩子中,用pubsub.unsubscribe(this.pid)去取消订阅。// A组件methods:&#123;  // 第一个参数是订阅事件的名字  demo(&#x27;aaa&#x27;,data)&#123; ... &#125;&#125;,... ...mounted()&#123;  this.pid = pubsub.subscribe(&#x27;aaa&#x27;,this.demo) //订阅消息&#125;,beforeDestroy()&#123;  pubsub.unsubscribe(this.pid)&#125;// B组件methods:&#123;  test()&#123;    pubsub.publish(&#x27;aaa&#x27;,params)  &#125;&#125;\n\n\n\nnextTick\n语法： this.$nextTick(callback)\n作用： 在下一次 dom 更新结束后执行其指定的回调函数\n什么时候用： 当改变数据后，要给予更新后的 dom 进行某些操作时，要在nextTick所指定的回调函数中执行\n\nVue封装的过渡与动画transition\n原理\n自动查看目标元素是否应用了CSS过渡或动画，如果有，那么在恰当的时机添加/删除CSS类名\n如果trnasition组件提供了JavaScript钩子函数，这些钩子函数将在恰当的时机被调用\n如果没有找到JavaScript钩子并且也没有检测到CSS过渡/动画，DOM插入、删除操作会立即执行\n\n\n\n\nv-enter-from: 定义过度开始的状态，在元素被插入之前生效，在元素被插入之后的下一帧移除\nv-enter-active: 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数\nv-enter-to: 定义进入过渡的结束状态。在元素被插入之后下一帧生效(此时v-enter-from)被移除，在过渡/动画完成之后移除\nv-leave-from: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧移除\nv-leave-active: 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过度被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数\nv-leave-to: 离开过渡的结束状态。在离开过渡被触发之后下一帧生效(此时v-leave-from被删除)，在过渡/动画完成之后移除\n\n  &lt;transition name=&quot;tt&quot;&gt;    &lt;h2 v-if=&quot;isShow&quot;&gt;Hello World!&lt;/h2&gt;&lt;/transition&gt;&lt;style&gt;  .tt-enter-from,    .tt-leave-to&#123;        // 变化效果        opacity: 0    &#125;        .tt-enter-to,    .tt-leave-from&#123;        // 变化效果        opacity: 1    &#125;        .tt-enter-active,    .tt-leave-active&#123;        transition: opacity 1s;    &#125;&lt;/style&gt;\n\n\nclass的name命名规则\n如果使用的是一个没有name的transition。那么所有class都是以v-作为默认前缀\n如果我们添加了一个name属性，比如&lt;transition name=&quot;tt&quot;&gt;,那么所有的class都会以tt-开头\n\n\n\n自定义过渡class\n自定义class的优先级高于普通的类名，可以使用第三方动画库的类名。 使用Animate.css 需要手动加上 animate__animated 动画时间类名 \n\n\nenter-from-class\n\nenter-active-class\n\nenter-to-class\n\nleave-from-class\n\nleave-active-class\n\nleave-to-class\n&lt;transition    enter-active-class=&quot;animate__animated animate__backInDown&quot;    leave-active-class=&quot;animate__animated animate__backOutUp&quot;&gt;      &lt;h2 v-if=&quot;isShow&quot;&gt;Hello World!&lt;/h2&gt;&lt;/transition&gt;\n\njs动画钩子\nbefore-enter\nenter\nafter-enter\nbefore-leave\nleave\nafter-leave&lt;transition    @before-enter=&quot;beforeEnter&quot;    @enter=&quot;enter&quot;    @after-enter=&quot;afterEnter&quot;    @before-leave=&quot;beforeLeave&quot;    @leave=&quot;Leave&quot;    @after-leave=&quot;afterLeave&quot;&gt;    &lt;h2 v-if=&quot;isShow&quot;&gt;Hello World!&lt;/h2&gt;&lt;/transition&gt;\n\nvue脚手架配置代理方法一  在vue.config.js中添加如下配置：\ndevServer:&#123;  proxy:&quot;http://localhost:5000&quot;  // 要访问的接口地址(只写到端口)&#125;// 发送请求时axios.get(&quot;/school&quot;).then()\n说明：\n\n优点：配置简单，请求资源时直接发给前端(8080)即可\n缺点：不能配置多个代理，不能灵活的控制请求是否走代理\n工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）\n\n方法二  编写vue.config.js配置具体代理规则：\nmodule.exports = &#123;  devServer:&#123;    proxy:&#123;      &#x27;/api1&#x27;: &#123;  //匹配所有以&#x27;/api1&#x27;开头的请求路径        target:&#x27;http://localhost:5000&#x27;, // 代理目标的基础路径        changeOrigin:true,        pathRewrite: &#123; &#x27;^/api1&#x27;: &#x27;&#x27; &#125;      &#125;,      &#x27;/api2&#x27;: &#123;  //匹配所有以&#x27;/api1&#x27;开头的请求路径        target:&#x27;http://localhost:5001&#x27;, // 代理目标的基础路径        changeOrigin:true,        pathRewrite: &#123; &#x27;^/api2&#x27;: &#x27;&#x27; &#125;      &#125;    &#125;  &#125;&#125;/*    changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000    changeOrigin设置为false时，服务器收到的请求头中的host为：localhost：8080    changeOrigin默认值为true*/// 发送请求时axios.get(&quot;/api/students&quot;).then()\n\n说明：\n\n优点：可以配置多个代理，且可以灵活地控制请求是否走代理\n配置略为繁琐。请求资源时必须要加前缀\n\n插槽\n作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信，适用于 父组件 ===&gt; 子组件 。\n\n分类：默认插槽、具名插槽、作用域插槽\n\n使用方式：\n\n默认插槽：\n父组件中：        &lt;Category&gt;            &lt;div&gt;html结构&lt;/div&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;!-- 定义插槽 --&gt;                &lt;slot&gt;默认值，当使用者没有传递具体结构时，标签内的内容会展示在页面上&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n具名插槽：\n父组件中：        &lt;Category&gt;            &lt;template slot=&quot;a&quot;&gt;                &lt;div&gt;html结构&lt;/div&gt;            &lt;/template&gt;            &lt;template slot:b&gt;                &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;!-- 定义插槽 --&gt;                &lt;slot name=&quot;a&quot;&gt;默认值，当使用者没有传递具体结构时，标签内的内容会展示在页面上&lt;/slot&gt;                &lt;slot name=&quot;b&quot;&gt;默认值，当使用者没有传递具体结构时，标签内的内容会展示在页面上&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n作用域插槽：\n\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用节决定。（games数据在Category组件中，但使用数据所遍历出来的结构由父组件决定）\n具体代码：父组件中：        &lt;Category&gt;            &lt;!-- scope 是一个对象，里面存放着子组件通过插槽传过来的数据 --&gt;            &lt;template scope=&quot;scopeData&quot;&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;game in scopeData.games&quot; :key=&quot;game&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;!-- 接收数据时可使用解构语法 --&gt;            &lt;template scope=&quot;&#123; games &#125;&quot;&gt;                &lt;h4 v-for=&quot;game in games&quot; :key=&quot;game&quot;&gt; &#123;&#123;game&#125;&#125;&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;        &lt;script&gt;          export default&#123;            name:&#x27;Category&#x27;,            data()&#123;              return &#123;                games:[&quot;双人成行&quot;, &quot;小小梦魇&quot;, &quot;冒险岛&quot;, &quot;魂斗罗&quot;]              &#125;            &#125;          &#125;        &lt;/script&gt;\n\n\n\n\n\nVuex概念  在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信\n何时使用？  多个组件需要共享数据时\n搭建vuex环境\n创建文件：src/store/index.js// 引入Vue核心库import Vue from &#x27;vue&#x27;// 引入Vueximport Vuex from &#x27;vuex&#x27;// 应用Vuex插件Vue.use(Vuex)// 准备actions对象 ———— 响应组件中用户的动作const actions = &#123;&#125;;// 准备mutations对象——修改state中的数据const mutations = &#123;&#125;;// 准备state对象——保存具体的数据const state = &#123;&#125;;//创建并暴露storeexport default new Vuex.Store(&#123;  actions,  mutations,  state&#125;)\n在main.js中创建vm时传入store配置项...// 引入storeimport store from &#x27;./store&#x27;...// 创建vmnew Vue(&#123;  el:&#x27;#app&#x27;,  render: h =&gt; h(App)，  store&#125;)\n\n基本使用\n初始化数据、配置actions、配置mutations，操作文件stroe/index.js// 引入vue核心库import Vue from &#x27;vue&#x27;// 引入vueximport Vuex from &#x27;vuex&#x27;// 应用VuexVue.ues(Vuex)const actions = &#123;  // 响应组件中加法的动作  jia(context, value)&#123;    context.commit(&#x27;JIA&#x27;,value);  &#125;&#125;;const mutations = &#123;  JIA(state,value)&#123;    state.sum += value;  &#125;&#125;const state = &#123;  num: 1&#125;//创建并暴露storeexport default new Vuex.Store(&#123;  actions,  mutations,  state&#125;)\n组件中读取vuex中的数据：$store.state.num\n组件中修改vuex中的数据：$store.dispatch(&#39;actions中的方法&#39;, 数据) 或 $store.commit(&#39;mutations中的方法名&#39;, 数据)\n备注：若没有网络请求或其他业务逻辑，可以越过actions直接调用mutations，即不写dispatch,直接调用commit\n\n\n\ngetters的使用\n概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。\n在store.js中追加getters配置......const getters = &#123;  bigNum(state)&#123;    return state.num * 10  &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;  ......  getters&#125;)\n组件中读取数据：$store.getters.bigNum\n\n四个map方法的使用\nmapState方法：用于映射state中的数据为计算属性\ncomputed:&#123;  // 借助mapState生成计算属性：num、school、subject（对象写法）  ...mapState(&#123;num:&#x27;num&#x27;, school:&#x27;school&#x27;, subject:&#x27;subject&#x27;&#125;),  // 借助mapState生成计算属性：num、school、subject（数组写法）  ...mapState([&#x27;num&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;])&#125;\nmapGetters方法：用于映射getters中的数据为计算属性\ncomputed:&#123;  // 借助mapGetters生成计算属性: bigNum(对象写法)  ...mapGetters(&#123;bigNum:&#x27;bigNum&#x27;&#125;)  // 借助mapGetters生成计算属性: bigNum(数组写法)  ...mapGetters([&#x27;bigNum&#x27;])&#125;\nmapActions方法：用于生成与actions对话的方式，即包含$store.dispatch(xxx)的函数\nmethods:&#123;  // 靠mapActions生成：incrementOdd、incrementWait（对象形式）  ...mapActions(&#123; incrementOdd:&#x27;jiaOdd&#x27;, incrementWait:&#x27;jiaWait&#x27; &#125;)  // 靠mapActions生成：jiaOdd、jiaWait（数组形式）  ...mapActions([&#x27;jiaOdd&#x27;, &#x27;jiaWait&#x27;])&#125;\nmapMutations方法：用于生成与mutations对话的方法，即包含$store.commit(xxx)的函数\n// 靠mapActions生成：increment、decrement（对象形式）...mapMutations(&#123; increment:&#x27;JIA&#x27;, decrement:&#x27;JIAN&#x27; &#125;)// 靠mapMutations生成：JIA、JIAN（对象形式）...mapMutations([ &#x27;JIA&#x27;, &#x27;JIAN&#x27; ])\n\n\n备注：mapActions与mapMutations使用时，如果要传递参数 需要在模板中绑定事件时传递参数，否则参数是事件对象。\n\n模块化 + 命名空间\n目的：让代码更好维护，让多种数据分类更加明确。\n\n修改: store.js\nconst countAbout = &#123;  namespaced: true, // 开启命名空间  state:&#123; ... &#125;,  mutations:&#123; ... &#125;,  actions:&#123; ... &#125;,  getters:&#123;    bigNum(state)&#123;      return state.sum * 10    &#125;  &#125;&#125;const personAbout = &#123;  namespaced: true, // 开启命名空间  state:&#123; ... &#125;,  mutations:&#123; ... &#125;,  actions:&#123; ... &#125;&#125;export default  new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)\n开启命名空间后，组件中读取state数据：\n// 方式一：自己直接读取this.$store.state.personAbout.list// 方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;, [&#x27;num&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;])\n开启命名空间后，组件中读取getters数据：\n// 方式一：自己直接读取//                    命名空间名  /  属性名this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]// 方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;, [&#x27;bigSum&#x27;])\n开启命名空间后，组件中调用dispatch\n //方式一：自己直接dispatch//                      命名空间名  /  方法名       , 参数 this.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person) //方式二：借助mapActions： ...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\n开启命名空间后，组件中调用commit\n //方式一：自己直接commit//                    命名空间名  /  方法名    , 参数 this.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person) //方式二：借助mapMutations： ...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\n\n路由\n理解：一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n前端路由：key是路径，value是组件。\n\n基本使用\n安装vue-router ：npm i vue-router\nmain.js中引入VueRouter: import VueRouter from &#39;vue-router&#39;\n应用插件：Vue.use(VueRouter)\n编写router配置项：/*  src/router/index.js  该文件专门用于创建整个应用的路由器*///引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入路由 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;// 创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;  routes:[    &#123;      path:&#x27;/home&#x27;,      component:Home    &#125;,    &#123;      path:&#x27;/about&#x27;,      component:About    &#125;  ]&#125;)export default router\n实现切换（active-class可配置高亮样式）&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n指定展示位置&lt;router-view&gt;&lt;/router-view&gt;\n\n几个注意点\n路由组件通常放在pages/views文件夹，一般组件通常放在components文件夹。\n通过切换，“隐藏”了的路由组件，默认是销毁掉的，需要的时候再去挂载。\n每个组件都有自己的$route属性，里面存储着自己的路由信息。\n整个应用只有一个router，可以通过组件的$router属性获取到。\n\n多级路由（多级路由）\n配置路由规则，使用children配置项：router:[  &#123;    path:&#x27;/about&#x27;,    component:About  &#125;,  &#123;    path:&#x27;/home&#x27;,    component:Home,    children:[  // 通过children配置子集路由      &#123;        path:&#x27;news&#x27;,  // 子级路由一定不要写斜线，不要写成&#x27;/news&#x27;        component: News      &#125;,      &#123;        path:&#x27;message&#x27;, // 子级路由一定不要写斜线!!!        component: Message      &#125;    ]  &#125;]\n跳转（要写完整的路径,从一级路由一级一级向下找）：&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;\n\n路由的query参数\n传递参数&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link to=&quot;/home/message/detail?id=666&amp;msg=hello&quot;&gt;&lt;/router-link&gt;&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link   :to=&quot;&#123;    path:&#x27;/home/message/detail&#x27;,    query:&#123;      id:666,      msg:&#x27;hello&#x27;    &#125;  &#125;&quot;&gt;跳转&lt;/router-link&gt;\n接受参数：$route.query.id$route.query.msg\n特别注意：若传递的参数是对象，页面刷新后数据会丢失，传参时可以使用JSON.stringify()避免该问题, 普通值不会丢失\n\n命名路由\n作用：可以简化路由的跳转\n如何使用\n给路由命名：&#123;  path:&#x27;/demo&#x27;,  component:Demo,  children:[    &#123;      path:&#x27;test&#x27;,      component:Test,      children:[        &#123;          name:&#x27;hello&#x27;,  // 给路由命名          path:&#x27;welcome&#x27;,          component: Hello        &#125;      ]    &#125;  ]&#125;\n简化跳转&lt;!-- 简化前，需要写完整路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!-- 简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!-- 简化写法配合传递参数 --&gt;&lt;router-link  :to=&#123;    name:&#x27;hello&#x27;,    query:&#123;      id:666,      msg:&#x27;hello&#x27;    &#125;  &#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n路由的params参数\n配置路由，声明接收params参数&#123;  path:&#x27;/home&#x27;,  component:Home,  children:[    &#123;      path:&#x27;news&#x27;,      component:News    &#125;,    &#123;      path:&#x27;message&#x27;,      component:Message,      children:[        &#123;          name:&#x27;detail&#x27;,          path:&#x27;detail/:id/:msg&#x27;,  // 使用占位符声明接收params参数          component: Detail        &#125;      ]    &#125;  ]&#125;\n传递参数&lt;!-- 跳转并携带params写法，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/hello&quot;&gt;跳转&lt;/router-link&gt;&lt;!-- 跳转并携带params写法，to的字符串写法 --&gt;&lt;router-link  :to=&quot;&#123;    name:&#x27;detail&#x27;,    params:&#123;      id:666,      msg:&#x27;hello&#x27;    &#125;  &#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n特别注意： 路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置项\n\n\n接收参数：$route.params.id$route.params.msg\n特别注意：若传递的参数是对象，页面刷新后数据会丢失，传参时可以使用JSON.stringify()避免该问题, 普通值不会丢失\n\n路由的props配置  作用：让路由组件更方便的接收到参数\n&#123;  name:&#x27;detail&#x27;,  path:&#x27;detail/:id&#x27;,  component:Detail,  // 第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件  //  props: &#123; a:1 &#125;  // 第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件  // 缺点: 不能接受query参数  // props: true  // 第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件  props(route)&#123;    return &#123;      id:route.query.id,      msg: route.query.msg    &#125;  &#125;  /* props(&#123; query &#125;) &#123;    return &#123;      id: query.id,      title: query.title    &#125;  &#125; */  /* // 解构赋值连续写法  props(&#123; query: &#123; id, title &#125; &#125;) &#123;    return &#123;      id: id,      title: title    &#125;  &#125; */&#125;\n\n&lt;router-link&gt; 的replace属性\n作用：控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写法： 分别为push和replace，push 是追加历史记录，replace是替换当前记录。路由跳转的时候默认为push\n如何开启replace模式： &lt;router-link replace ......&gt;跳转&lt;/router-link&gt;\n\n编程式路由导航\n作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更灵活\n具体编码：// $router 的APIthis.$router.push(&#123;  name:&#x27;detail&#x27;,  params:&#123;    id:&#x27;xxx&#x27;,    msg:&#x27;xxx&#x27;  &#125;&#125;)this.$router.replace(&#123;  name:&#x27;detail&#x27;,  params:&#123;    id:&#x27;xxx&#x27;,    msg:&#x27;xxx&#x27;  &#125;&#125;)this.$router.forward() // 前进this.$router.back()  // 后退this.$router.go()  //可前进也可后退\n\n缓存路由组件\n作用：让不展示的路由组件保持挂载，不被销毁\n具体编码：&lt;keep-alive :include=&quot;组件名(组件name保存的名字)&quot;&gt;  &lt;组件名&gt;&lt;/组件名&gt;&lt;/keep-alive&gt;include: string | RegExp| Array。只有名称匹配的组件会被缓存；exclude: string | RegExp| Array。任何名称匹配的组件都不会被缓存；max: number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁\n缓存组件独有的生命周期，用于捕获路由组件的激活状态\nactivated 组件激活时触发的钩子\ndeactivated 组件失活时触发的钩子\n\n路由守卫\n作用： 对路由进行权限控制\n分类： 全局守卫、独享守卫、组件内守卫\n全局守卫：// router/index.js 文件内编写// 全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach( (to, from, next)=&gt;&#123;  console.log(&#x27;beforeEach&#x27;,to,from)  if(to.meta.isAuth)&#123;  // 判断当前路由是否需要进行权限控制    // 逻辑操作    next() // 放行  &#125;else&#123;    next(&#123;name:&#x27;home&#x27;&#125;)  // 重定向    // throw new Error()  &#125;&#125;)// 全局后置守卫： 初始化时执行、每次路由切换后执行router.afterEach( (to, from)=&gt;&#123; //  to : 到哪去 ； from 从哪来     console.log(&#x27;afterEach&#x27;, to, from)  if(to.meta.title)&#123;  // 判断当前路由是否需要进行权限控制    document.title = to.meta.title  // 修改网页的title  &#125;else&#123;    document.title = &#x27;xxx&#x27;  &#125;&#125;)\n独享守卫：// router/index.js 文件内编写beforeEnter(to, from, next)&#123;  console.log(&#x27;beforeEnter&#x27;,to,from)  if(to.meta.isAuth)&#123;  // 判断当前路由是否需要进行权限控制    // 逻辑操作    next() // 放行  &#125;else&#123;    next(&#123;name:&#x27;home&#x27;&#125;)  // 重定向    // throw new Error()  &#125;&#125;\n组件内守卫：//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;\n\n路由器的两种工作模式\n对于一个url来说，什么事hash值？ ———— #及其后面的内容就是hash值\nhash值不会包含在HTTP请求中，即：hash值不会带给服务器\nhash模式：\n地址中带有#号，不美观\n若以后将地址通过第三方手机app分享，如果app校验严格，则地址会被标记为不合法\n兼容性较好\n\n\nhistory模式：\nurl地址没有 #\n兼容性与hash模式相比略差\n应用部署上线时需要后端人员支持，解决刷新页面服务端404问题\n\n\n\n","categories":["Vue"],"tags":["Vue-cli笔记"]}]